<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::detail_::ModuleManagerPIMPL Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pluginplay
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pluginplay::detail_::ModuleManagerPIMPL Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class that implements the ModuleManager.  
 <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="module__manager__pimpl_8hpp_source.html">module_manager_pimpl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aa1ffd56ee317f3b75e32fb0eacbeac11"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa1ffd56ee317f3b75e32fb0eacbeac11">module_base_ptr</a> = typename ModuleManager::module_base_ptr</td></tr>
<tr class="separator:aa1ffd56ee317f3b75e32fb0eacbeac11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182756f17829201570c9dd70e67ee526"><td class="memItemLeft" align="right" valign="top"><a id="a182756f17829201570c9dd70e67ee526"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a182756f17829201570c9dd70e67ee526">const_module_base_ptr</a> = typename ModuleManager::const_module_base_ptr</td></tr>
<tr class="memdesc:a182756f17829201570c9dd70e67ee526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a read-only module implementation. <br /></td></tr>
<tr class="separator:a182756f17829201570c9dd70e67ee526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef4cea5e253855401746745f27c02f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#abef4cea5e253855401746745f27c02f4">base_map</a> = std::map&lt; std::type_index, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a182756f17829201570c9dd70e67ee526">const_module_base_ptr</a> &gt;</td></tr>
<tr class="separator:abef4cea5e253855401746745f27c02f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea69e3a0fe511e38d2637af68335945e"><td class="memItemLeft" align="right" valign="top"><a id="aea69e3a0fe511e38d2637af68335945e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aea69e3a0fe511e38d2637af68335945e">shared_module</a> = std::shared_ptr&lt; Module &gt;</td></tr>
<tr class="memdesc:aea69e3a0fe511e38d2637af68335945e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a usable module. <br /></td></tr>
<tr class="separator:aea69e3a0fe511e38d2637af68335945e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55803300f0e51ec05ab06302ee1ab90d"><td class="memItemLeft" align="right" valign="top"><a id="a55803300f0e51ec05ab06302ee1ab90d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a55803300f0e51ec05ab06302ee1ab90d">module_map</a> = utilities::CaseInsensitiveMap&lt; <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aea69e3a0fe511e38d2637af68335945e">shared_module</a> &gt;</td></tr>
<tr class="memdesc:a55803300f0e51ec05ab06302ee1ab90d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map holding usable modules. <br /></td></tr>
<tr class="separator:a55803300f0e51ec05ab06302ee1ab90d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75216a136de412eb1bc3abc7398b3564"><td class="memItemLeft" align="right" valign="top"><a id="a75216a136de412eb1bc3abc7398b3564"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a75216a136de412eb1bc3abc7398b3564">cache_type</a> = typename <a class="el" href="classpluginplay_1_1detail___1_1ModulePIMPL.html#aab357fae1517a5665ce993733c65bab5">ModulePIMPL::cache_type</a></td></tr>
<tr class="memdesc:a75216a136de412eb1bc3abc7398b3564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a cache. <br /></td></tr>
<tr class="separator:a75216a136de412eb1bc3abc7398b3564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa106e9d3327b951e1568c8dd317616cb"><td class="memItemLeft" align="right" valign="top"><a id="aa106e9d3327b951e1568c8dd317616cb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa106e9d3327b951e1568c8dd317616cb">shared_cache</a> = std::shared_ptr&lt; <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a75216a136de412eb1bc3abc7398b3564">cache_type</a> &gt;</td></tr>
<tr class="memdesc:aa106e9d3327b951e1568c8dd317616cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a shared cache. <br /></td></tr>
<tr class="separator:aa106e9d3327b951e1568c8dd317616cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f7e61be103d2e05787222a84ad0b1b"><td class="memItemLeft" align="right" valign="top"><a id="a08f7e61be103d2e05787222a84ad0b1b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a08f7e61be103d2e05787222a84ad0b1b">cache_map</a> = std::map&lt; std::type_index, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa106e9d3327b951e1568c8dd317616cb">shared_cache</a> &gt;</td></tr>
<tr class="memdesc:a08f7e61be103d2e05787222a84ad0b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map holding caches. <br /></td></tr>
<tr class="separator:a08f7e61be103d2e05787222a84ad0b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2379e2f590fa48050845a92aed64d7f"><td class="memItemLeft" align="right" valign="top"><a id="aa2379e2f590fa48050845a92aed64d7f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa2379e2f590fa48050845a92aed64d7f">default_map</a> = std::map&lt; std::type_index, type::key &gt;</td></tr>
<tr class="memdesc:aa2379e2f590fa48050845a92aed64d7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map holding the default module key for a given property type. <br /></td></tr>
<tr class="separator:aa2379e2f590fa48050845a92aed64d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41f9ab2a37c36f7def463812a1072c52"><td class="memItemLeft" align="right" valign="top"><a id="a41f9ab2a37c36f7def463812a1072c52"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a41f9ab2a37c36f7def463812a1072c52">clone</a> ()</td></tr>
<tr class="memdesc:a41f9ab2a37c36f7def463812a1072c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of this instance on the heap. <br /></td></tr>
<tr class="separator:a41f9ab2a37c36f7def463812a1072c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156bd4b3be18eb8b5e1487a33c4dab4b"><td class="memItemLeft" align="right" valign="top"><a id="a156bd4b3be18eb8b5e1487a33c4dab4b"></a>
type::size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a156bd4b3be18eb8b5e1487a33c4dab4b">count</a> (const type::key &amp;key) const noexcept</td></tr>
<tr class="memdesc:a156bd4b3be18eb8b5e1487a33c4dab4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures we determine if we have a module consistently. <br /></td></tr>
<tr class="separator:a156bd4b3be18eb8b5e1487a33c4dab4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b63c72546b2c67027ecca562c863cb3"><td class="memItemLeft" align="right" valign="top"><a id="a1b63c72546b2c67027ecca562c863cb3"></a>
type::size&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a1b63c72546b2c67027ecca562c863cb3">size</a> () const noexcept</td></tr>
<tr class="memdesc:a1b63c72546b2c67027ecca562c863cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures we count the number of modules consistently. <br /></td></tr>
<tr class="separator:a1b63c72546b2c67027ecca562c863cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4671dfdce0eec13b2c126aa916222f55"><td class="memItemLeft" align="right" valign="top">module_map::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a4671dfdce0eec13b2c126aa916222f55">begin</a> () noexcept</td></tr>
<tr class="memdesc:a4671dfdce0eec13b2c126aa916222f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the first element of the module map.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a4671dfdce0eec13b2c126aa916222f55">More...</a><br /></td></tr>
<tr class="separator:a4671dfdce0eec13b2c126aa916222f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b18dce75e700f5ab48327dcb740c160"><td class="memItemLeft" align="right" valign="top">module_map::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a8b18dce75e700f5ab48327dcb740c160">end</a> () noexcept</td></tr>
<tr class="memdesc:a8b18dce75e700f5ab48327dcb740c160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterator to the past-the-end element of the module map.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a8b18dce75e700f5ab48327dcb740c160">More...</a><br /></td></tr>
<tr class="separator:a8b18dce75e700f5ab48327dcb740c160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7272272282ab306960406e5aa61406"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a0b7272272282ab306960406e5aa61406">set_default</a> (const std::type_info &amp;type, type::input_map inputs, type::key key)</td></tr>
<tr class="memdesc:a0b7272272282ab306960406e5aa61406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default module to use for a given property type.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a0b7272272282ab306960406e5aa61406">More...</a><br /></td></tr>
<tr class="separator:a0b7272272282ab306960406e5aa61406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95ab05fbd503c8e07738edf180a7eeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ae95ab05fbd503c8e07738edf180a7eeb">add_module</a> (type::key key, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa1ffd56ee317f3b75e32fb0eacbeac11">module_base_ptr</a> base)</td></tr>
<tr class="memdesc:ae95ab05fbd503c8e07738edf180a7eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function actually adds a module to the list of available modules.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#ae95ab05fbd503c8e07738edf180a7eeb">More...</a><br /></td></tr>
<tr class="separator:ae95ab05fbd503c8e07738edf180a7eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7fb8c8d46b45ff3133b106696e9a8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a5d7fb8c8d46b45ff3133b106696e9a8c">erase</a> (const type::key &amp;key)</td></tr>
<tr class="memdesc:a5d7fb8c8d46b45ff3133b106696e9a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unloads the specified module.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a5d7fb8c8d46b45ff3133b106696e9a8c">More...</a><br /></td></tr>
<tr class="separator:a5d7fb8c8d46b45ff3133b106696e9a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41e4fd159a783b8c2c3c96940b2f26c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa41e4fd159a783b8c2c3c96940b2f26c">copy_module</a> (const type::key &amp;old_key, type::key new_key)</td></tr>
<tr class="memdesc:aa41e4fd159a783b8c2c3c96940b2f26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of a module.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa41e4fd159a783b8c2c3c96940b2f26c">More...</a><br /></td></tr>
<tr class="separator:aa41e4fd159a783b8c2c3c96940b2f26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9229a669f41ecf142a6f894dd5dd12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aea69e3a0fe511e38d2637af68335945e">shared_module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a5f9229a669f41ecf142a6f894dd5dd12">at</a> (const type::key &amp;key)</td></tr>
<tr class="memdesc:a5f9229a669f41ecf142a6f894dd5dd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a module, filling in all non-set submodules with defaults if a ready default exists.  <a href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a5f9229a669f41ecf142a6f894dd5dd12">More...</a><br /></td></tr>
<tr class="separator:a5f9229a669f41ecf142a6f894dd5dd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr class="memitem:a2971b011c0c9669111b448c611e30064"><td class="memItemLeft" align="right" valign="top"><a id="a2971b011c0c9669111b448c611e30064"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a> &amp;rhs) const</td></tr>
<tr class="separator:a2971b011c0c9669111b448c611e30064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e037e95c9d1980ab93d54fb8b739f9"><td class="memItemLeft" align="right" valign="top"><a id="ac6e037e95c9d1980ab93d54fb8b739f9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a> &amp;rhs) const</td></tr>
<tr class="separator:ac6e037e95c9d1980ab93d54fb8b739f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">ModuleManager state</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The members in this section are the state of the ModuleManager class. </p>
</div></td></tr>
<tr class="memitem:a6bdbd621fe2f74dc95f09ea9c5e4aa21"><td class="memItemLeft" align="right" valign="top"><a id="a6bdbd621fe2f74dc95f09ea9c5e4aa21"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#abef4cea5e253855401746745f27c02f4">base_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_bases</b></td></tr>
<tr class="separator:a6bdbd621fe2f74dc95f09ea9c5e4aa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c56512098f34acf3d4011c973c0bf34"><td class="memItemLeft" align="right" valign="top"><a id="a1c56512098f34acf3d4011c973c0bf34"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a55803300f0e51ec05ab06302ee1ab90d">module_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_modules</b></td></tr>
<tr class="separator:a1c56512098f34acf3d4011c973c0bf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3800bf89fca758e34f2ed70f2548f4b"><td class="memItemLeft" align="right" valign="top"><a id="aa3800bf89fca758e34f2ed70f2548f4b"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a08f7e61be103d2e05787222a84ad0b1b">cache_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_caches</b></td></tr>
<tr class="separator:aa3800bf89fca758e34f2ed70f2548f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd56b70df204fc01fde0834e8430ab19"><td class="memItemLeft" align="right" valign="top"><a id="afd56b70df204fc01fde0834e8430ab19"></a>
<a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa2379e2f590fa48050845a92aed64d7f">default_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_defaults</b></td></tr>
<tr class="separator:afd56b70df204fc01fde0834e8430ab19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d4842cc386daa0a0381865dcb0ad83"><td class="memItemLeft" align="right" valign="top"><a id="a92d4842cc386daa0a0381865dcb0ad83"></a>
std::map&lt; std::type_index, type::input_map &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_inputs</b></td></tr>
<tr class="separator:a92d4842cc386daa0a0381865dcb0ad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class that implements the ModuleManager. </p>
<p>Users are expected to go through the API provided by the ModuleManager class. Inside the ModuleManager class calls are redirected to this class. When using this class calls should go through the member functions as much as possible so that error checking occurs. That said members are public so that it is easier to test the implementation. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abef4cea5e253855401746745f27c02f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef4cea5e253855401746745f27c02f4">&#9670;&nbsp;</a></span>base_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#abef4cea5e253855401746745f27c02f4">pluginplay::detail_::ModuleManagerPIMPL::base_map</a> =  std::map&lt;std::type_index, <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#a182756f17829201570c9dd70e67ee526">const_module_base_ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a map from the module implementation's type to the implementation </p>

</div>
</div>
<a id="aa1ffd56ee317f3b75e32fb0eacbeac11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ffd56ee317f3b75e32fb0eacbeac11">&#9670;&nbsp;</a></span>module_base_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa1ffd56ee317f3b75e32fb0eacbeac11">pluginplay::detail_::ModuleManagerPIMPL::module_base_ptr</a> =  typename ModuleManager::module_base_ptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a pointer to a module's implemenation </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae95ab05fbd503c8e07738edf180a7eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95ab05fbd503c8e07738edf180a7eeb">&#9670;&nbsp;</a></span>add_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::detail_::ModuleManagerPIMPL::add_module </td>
          <td>(</td>
          <td class="paramtype">type::key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aa1ffd56ee317f3b75e32fb0eacbeac11">module_base_ptr</a>&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function actually adds a module to the list of available modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key under which the module will be registered. </td></tr>
    <tr><td class="paramname">base</td><td>The instance containing the algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f9229a669f41ecf142a6f894dd5dd12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f9229a669f41ecf142a6f894dd5dd12">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpluginplay_1_1detail___1_1ModuleManagerPIMPL.html#aea69e3a0fe511e38d2637af68335945e">shared_module</a> pluginplay::detail_::ModuleManagerPIMPL::at </td>
          <td>(</td>
          <td class="paramtype">const type::key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a module, filling in all non-set submodules with defaults if a ready default exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The module you want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared_ptr to the requested module </dd></dl>

</div>
</div>
<a id="a4671dfdce0eec13b2c126aa916222f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4671dfdce0eec13b2c126aa916222f55">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">module_map::iterator pluginplay::detail_::ModuleManagerPIMPL::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the first element of the module map. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the first element of the map </dd></dl>

</div>
</div>
<a id="aa41e4fd159a783b8c2c3c96940b2f26c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41e4fd159a783b8c2c3c96940b2f26c">&#9670;&nbsp;</a></span>copy_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::detail_::ModuleManagerPIMPL::copy_module </td>
          <td>(</td>
          <td class="paramtype">const type::key &amp;&#160;</td>
          <td class="paramname"><em>old_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type::key&#160;</td>
          <td class="paramname"><em>new_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a deep copy of a module. </p>
<p>This function makes a deep copy of a module. The new module is unlocked regardless of whether the old module was locked or not. The user can call lock on the resulting module to make an exact copy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_key</td><td>The key for the module to copy </td></tr>
    <tr><td class="paramname">new_key</td><td>The key under which the new module will live </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b18dce75e700f5ab48327dcb740c160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b18dce75e700f5ab48327dcb740c160">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">module_map::iterator pluginplay::detail_::ModuleManagerPIMPL::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterator to the past-the-end element of the module map. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the past-the-end element of the map </dd></dl>

</div>
</div>
<a id="a5d7fb8c8d46b45ff3133b106696e9a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7fb8c8d46b45ff3133b106696e9a8c">&#9670;&nbsp;</a></span>erase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::detail_::ModuleManagerPIMPL::erase </td>
          <td>(</td>
          <td class="paramtype">const type::key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unloads the specified module. </p>
<p>This function unloads the module with the specified key. After this operation the key is free to be used again. Calling this function does NOT clean any data out of the cache. This function is a no-op if <code>key</code> does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key for the module which should be erased.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b7272272282ab306960406e5aa61406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7272272282ab306960406e5aa61406">&#9670;&nbsp;</a></span>set_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::detail_::ModuleManagerPIMPL::set_default </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type::input_map&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type::key&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default module to use for a given property type. </p>
<p>When a user requests a module that module initially has no submodules set unless the user has bound some to that module. Instead, the ModuleManager is now responsible to provide the module with submodules using the defaults. This function allows one to specify what the defaults are.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the property type this default is for </td></tr>
    <tr><td class="paramname">key</td><td>The module key for the module to use as the default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>src/pluginplay/detail_/<a class="el" href="module__manager__pimpl_8hpp_source.html">module_manager_pimpl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
