<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sde: sde::Module Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sde</b></li><li class="navelem"><a class="el" href="classsde_1_1Module.html">Module</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsde_1_1Module-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sde::Module Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The public API of all modules.  
 <a href="classsde_1_1Module.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="module_8hpp_source.html">module.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7132ef4b522f5f4c09bead25f6ab8646"><td class="memItemLeft" align="right" valign="top"><a id="a7132ef4b522f5f4c09bead25f6ab8646"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a7132ef4b522f5f4c09bead25f6ab8646">pimpl_ptr</a> = std::unique_ptr&lt; <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">detail_::ModulePIMPL</a> &gt;</td></tr>
<tr class="memdesc:a7132ef4b522f5f4c09bead25f6ab8646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a pointer to a PIMPL. <br /></td></tr>
<tr class="separator:a7132ef4b522f5f4c09bead25f6ab8646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb2aa36bc63794a6cab2f58e579baf7"><td class="memItemLeft" align="right" valign="top"><a id="a0eb2aa36bc63794a6cab2f58e579baf7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a0eb2aa36bc63794a6cab2f58e579baf7">not_ready_type</a> = utilities::CaseInsensitiveMap&lt; std::set&lt; <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &gt; &gt;</td></tr>
<tr class="memdesc:a0eb2aa36bc63794a6cab2f58e579baf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the object used to convey why a module is not ready. <br /></td></tr>
<tr class="separator:a0eb2aa36bc63794a6cab2f58e579baf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a155f4cf9a94036661914ffd445704b56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a155f4cf9a94036661914ffd445704b56">Module</a> ()</td></tr>
<tr class="memdesc:a155f4cf9a94036661914ffd445704b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a module with no implementation.  <a href="#a155f4cf9a94036661914ffd445704b56">More...</a><br /></td></tr>
<tr class="separator:a155f4cf9a94036661914ffd445704b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef87458ab633dd06bce9203cd65e9fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#acef87458ab633dd06bce9203cd65e9fc">Module</a> (const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;rhs)</td></tr>
<tr class="memdesc:acef87458ab633dd06bce9203cd65e9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializing this <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> with a deep copy of <code>rhs</code>.  <a href="#acef87458ab633dd06bce9203cd65e9fc">More...</a><br /></td></tr>
<tr class="separator:acef87458ab633dd06bce9203cd65e9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b87712b71a3e9fb1796ef4cf75d725d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1Module.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a6b87712b71a3e9fb1796ef4cf75d725d">operator=</a> (const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;rhs)</td></tr>
<tr class="memdesc:a6b87712b71a3e9fb1796ef4cf75d725d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a>'s state to a deep copy of <code>rhs</code>.  <a href="#a6b87712b71a3e9fb1796ef4cf75d725d">More...</a><br /></td></tr>
<tr class="separator:a6b87712b71a3e9fb1796ef4cf75d725d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e46b6c0091271d5e1646c5392f5801"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#aa1e46b6c0091271d5e1646c5392f5801">Module</a> (<a class="el" href="classsde_1_1Module.html">Module</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:aa1e46b6c0091271d5e1646c5392f5801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> with <code>rhs's</code> state.  <a href="#aa1e46b6c0091271d5e1646c5392f5801">More...</a><br /></td></tr>
<tr class="separator:aa1e46b6c0091271d5e1646c5392f5801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd94d82a291ab243a3031897005666fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1Module.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#abd94d82a291ab243a3031897005666fd">operator=</a> (<a class="el" href="classsde_1_1Module.html">Module</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:abd94d82a291ab243a3031897005666fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a>'s state to <code>rhs's</code> state.  <a href="#abd94d82a291ab243a3031897005666fd">More...</a><br /></td></tr>
<tr class="separator:abd94d82a291ab243a3031897005666fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dcc9542daf09edb856d3a3a4c267706"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a9dcc9542daf09edb856d3a3a4c267706">Module</a> (std::unique_ptr&lt; <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &gt; ptr)</td></tr>
<tr class="memdesc:a9dcc9542daf09edb856d3a3a4c267706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> with the provided implementation.  <a href="#a9dcc9542daf09edb856d3a3a4c267706">More...</a><br /></td></tr>
<tr class="separator:a9dcc9542daf09edb856d3a3a4c267706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8964c3cfaa22ab0422bd8bc85d6e8f95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a8964c3cfaa22ab0422bd8bc85d6e8f95">Module</a> (<a class="el" href="classsde_1_1Module.html#a7132ef4b522f5f4c09bead25f6ab8646">pimpl_ptr</a> base) noexcept</td></tr>
<tr class="memdesc:a8964c3cfaa22ab0422bd8bc85d6e8f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instantiates a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> with the provided backend.  <a href="#a8964c3cfaa22ab0422bd8bc85d6e8f95">More...</a><br /></td></tr>
<tr class="separator:a8964c3cfaa22ab0422bd8bc85d6e8f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a97eb40f323f9df8b95aefdfb69c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1Module.html">Module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a48a97eb40f323f9df8b95aefdfb69c3d">unlocked_copy</a> () const</td></tr>
<tr class="memdesc:a48a97eb40f323f9df8b95aefdfb69c3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an unlocked deep copy of this module.  <a href="#a48a97eb40f323f9df8b95aefdfb69c3d">More...</a><br /></td></tr>
<tr class="separator:a48a97eb40f323f9df8b95aefdfb69c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5a7a0a6c860820f9eeb401914d0592"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a3b5a7a0a6c860820f9eeb401914d0592">~Module</a> () noexcept</td></tr>
<tr class="memdesc:a3b5a7a0a6c860820f9eeb401914d0592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard destructor.  <a href="#a3b5a7a0a6c860820f9eeb401914d0592">More...</a><br /></td></tr>
<tr class="separator:a3b5a7a0a6c860820f9eeb401914d0592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc1f98ca7b000a584dd5909a552ec7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a9cc1f98ca7b000a584dd5909a552ec7a">has_module</a> () const noexcept</td></tr>
<tr class="memdesc:a9cc1f98ca7b000a584dd5909a552ec7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this module contain an implementation?  <a href="#a9cc1f98ca7b000a584dd5909a552ec7a">More...</a><br /></td></tr>
<tr class="separator:a9cc1f98ca7b000a584dd5909a552ec7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade8872f2ec304bad32aba270dcc85ebc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#ade8872f2ec304bad32aba270dcc85ebc">has_description</a> () const</td></tr>
<tr class="memdesc:ade8872f2ec304bad32aba270dcc85ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did the module developer set a description for this module?  <a href="#ade8872f2ec304bad32aba270dcc85ebc">More...</a><br /></td></tr>
<tr class="separator:ade8872f2ec304bad32aba270dcc85ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3e9324f7eb75d4b39bca2f15da34a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a1a3e9324f7eb75d4b39bca2f15da34a5">locked</a> () const noexcept</td></tr>
<tr class="memdesc:a1a3e9324f7eb75d4b39bca2f15da34a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the current module locked?  <a href="#a1a3e9324f7eb75d4b39bca2f15da34a5">More...</a><br /></td></tr>
<tr class="separator:a1a3e9324f7eb75d4b39bca2f15da34a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed2c33f43f1de79679cc2aaa613871f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1Module.html#a0eb2aa36bc63794a6cab2f58e579baf7">not_ready_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a9ed2c33f43f1de79679cc2aaa613871f">list_not_ready</a> (const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;in_inputs={}) const</td></tr>
<tr class="memdesc:a9ed2c33f43f1de79679cc2aaa613871f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of module state that is not "ready".  <a href="#a9ed2c33f43f1de79679cc2aaa613871f">More...</a><br /></td></tr>
<tr class="separator:a9ed2c33f43f1de79679cc2aaa613871f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab29fbfa743e082354cafa6151d538a6"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType &gt; </td></tr>
<tr class="memitem:aab29fbfa743e082354cafa6151d538a6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#aab29fbfa743e082354cafa6151d538a6">ready</a> () const</td></tr>
<tr class="memdesc:aab29fbfa743e082354cafa6151d538a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this module is ready to be run as the provided property type.  <a href="#aab29fbfa743e082354cafa6151d538a6">More...</a><br /></td></tr>
<tr class="separator:aab29fbfa743e082354cafa6151d538a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ce7c4d91ee1c093b6197d2441fc2aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a55ce7c4d91ee1c093b6197d2441fc2aa">ready</a> (const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;inps=<a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a>{}) const</td></tr>
<tr class="memdesc:a55ce7c4d91ee1c093b6197d2441fc2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this module is ready to be run given the inputs provided.  <a href="#a55ce7c4d91ee1c093b6197d2441fc2aa">More...</a><br /></td></tr>
<tr class="separator:a55ce7c4d91ee1c093b6197d2441fc2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28bcc7a0e0af3088a3aa8da4525c1b82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a28bcc7a0e0af3088a3aa8da4525c1b82">lock</a> ()</td></tr>
<tr class="memdesc:a28bcc7a0e0af3088a3aa8da4525c1b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the module and all submodules.  <a href="#a28bcc7a0e0af3088a3aa8da4525c1b82">More...</a><br /></td></tr>
<tr class="separator:a28bcc7a0e0af3088a3aa8da4525c1b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dece772a6a9c5b1e2903b9c24445e45"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a0dece772a6a9c5b1e2903b9c24445e45">results</a> () const</td></tr>
<tr class="memdesc:a0dece772a6a9c5b1e2903b9c24445e45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of results that can be computed by this module.  <a href="#a0dece772a6a9c5b1e2903b9c24445e45">More...</a><br /></td></tr>
<tr class="separator:a0dece772a6a9c5b1e2903b9c24445e45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5154bc599ed119c31771ee2f13bc2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a1c5154bc599ed119c31771ee2f13bc2f">inputs</a> () const</td></tr>
<tr class="memdesc:a1c5154bc599ed119c31771ee2f13bc2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inputs this module recognizes.  <a href="#a1c5154bc599ed119c31771ee2f13bc2f">More...</a><br /></td></tr>
<tr class="separator:a1c5154bc599ed119c31771ee2f13bc2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1aedde11932b2ba7781a17b15080b6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#a347228253f8054a46b3c53da07e7890b">type::submodule_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#abc1aedde11932b2ba7781a17b15080b6">submods</a> () const</td></tr>
<tr class="memdesc:abc1aedde11932b2ba7781a17b15080b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the submodule callback points defined by this module.  <a href="#abc1aedde11932b2ba7781a17b15080b6">More...</a><br /></td></tr>
<tr class="separator:abc1aedde11932b2ba7781a17b15080b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c88c7417c8a6e01a08da71bcd5857da"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="namespacesde_1_1type.html#a57864c40693cc764558896980ab0be01">type::rtti</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a0c88c7417c8a6e01a08da71bcd5857da">property_types</a> () const</td></tr>
<tr class="memdesc:a0c88c7417c8a6e01a08da71bcd5857da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of property types that this module can be run as.  <a href="#a0c88c7417c8a6e01a08da71bcd5857da">More...</a><br /></td></tr>
<tr class="separator:a0c88c7417c8a6e01a08da71bcd5857da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9ecb93f7030a7caf68648207f30090"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a1e9ecb93f7030a7caf68648207f30090">description</a> () const</td></tr>
<tr class="memdesc:a1e9ecb93f7030a7caf68648207f30090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the human-readable description provided by the developer.  <a href="#a1e9ecb93f7030a7caf68648207f30090">More...</a><br /></td></tr>
<tr class="separator:a1e9ecb93f7030a7caf68648207f30090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c56666e9d880dbc60debc43150e13f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a62c56666e9d880dbc60debc43150e13f">citations</a> () const</td></tr>
<tr class="memdesc:a62c56666e9d880dbc60debc43150e13f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of things to cite if you use the module.  <a href="#a62c56666e9d880dbc60debc43150e13f">More...</a><br /></td></tr>
<tr class="separator:a62c56666e9d880dbc60debc43150e13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629f560061c356e7075ab4c416d4ab4a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a629f560061c356e7075ab4c416d4ab4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a629f560061c356e7075ab4c416d4ab4a">change_input</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key, T &amp;&amp;value)</td></tr>
<tr class="memdesc:a629f560061c356e7075ab4c416d4ab4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binds an input value to the specified input.  <a href="#a629f560061c356e7075ab4c416d4ab4a">More...</a><br /></td></tr>
<tr class="separator:a629f560061c356e7075ab4c416d4ab4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa538341cce5d877936120604474e9aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#aa538341cce5d877936120604474e9aca">change_submod</a> (<a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> key, <a class="el" href="classsde_1_1Module.html">Module</a> new_mod)</td></tr>
<tr class="memdesc:aa538341cce5d877936120604474e9aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the specified submodule to the provided module.  <a href="#aa538341cce5d877936120604474e9aca">More...</a><br /></td></tr>
<tr class="separator:aa538341cce5d877936120604474e9aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c38fd962301e08e8a9d4651ed929d19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a7c38fd962301e08e8a9d4651ed929d19">change_submod</a> (<a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> key, std::shared_ptr&lt; <a class="el" href="classsde_1_1Module.html">Module</a> &gt; new_module)</td></tr>
<tr class="memdesc:a7c38fd962301e08e8a9d4651ed929d19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows the user to change the submodule a module uses.  <a href="#a7c38fd962301e08e8a9d4651ed929d19">More...</a><br /></td></tr>
<tr class="separator:a7c38fd962301e08e8a9d4651ed929d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb265bd57b5f5cda1bf045e9178951a"><td class="memTemplParams" colspan="2">template&lt;typename PropertyType &gt; </td></tr>
<tr class="memitem:a5eb265bd57b5f5cda1bf045e9178951a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a5eb265bd57b5f5cda1bf045e9178951a">add_property_type</a> ()</td></tr>
<tr class="memdesc:a5eb265bd57b5f5cda1bf045e9178951a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the module satisfy the specified property type.  <a href="#a5eb265bd57b5f5cda1bf045e9178951a">More...</a><br /></td></tr>
<tr class="separator:a5eb265bd57b5f5cda1bf045e9178951a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffa0771774b59785bf8270679ef27a4"><td class="memTemplParams" colspan="2">template&lt;typename property_type , typename... Args&gt; </td></tr>
<tr class="memitem:afffa0771774b59785bf8270679ef27a4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#afffa0771774b59785bf8270679ef27a4">run_as</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:afffa0771774b59785bf8270679ef27a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The primary API for running the encapsulated code.  <a href="#afffa0771774b59785bf8270679ef27a4">More...</a><br /></td></tr>
<tr class="separator:afffa0771774b59785bf8270679ef27a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758b7d9c7154626ea11d898dec192f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a758b7d9c7154626ea11d898dec192f56">run</a> (<a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> ps={})</td></tr>
<tr class="memdesc:a758b7d9c7154626ea11d898dec192f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">The advanced API for running the module.  <a href="#a758b7d9c7154626ea11d898dec192f56">More...</a><br /></td></tr>
<tr class="separator:a758b7d9c7154626ea11d898dec192f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a27e835cc714d439c3feb88e11ff6a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a49a27e835cc714d439c3feb88e11ff6a">profile_info</a> () const</td></tr>
<tr class="memdesc:a49a27e835cc714d439c3feb88e11ff6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns timing data for this module and all submodules.  <a href="#a49a27e835cc714d439c3feb88e11ff6a">More...</a><br /></td></tr>
<tr class="separator:a49a27e835cc714d439c3feb88e11ff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f01f68786c435aa480abde606ecb24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a41f01f68786c435aa480abde606ecb24">hash</a> (<a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;h) const</td></tr>
<tr class="memdesc:a41f01f68786c435aa480abde606ecb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a hash of the module's state.  <a href="#a41f01f68786c435aa480abde606ecb24">More...</a><br /></td></tr>
<tr class="separator:a41f01f68786c435aa480abde606ecb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898f036d2ff09cd028f0796b91c716ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a898f036d2ff09cd028f0796b91c716ab">operator==</a> (const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a898f036d2ff09cd028f0796b91c716ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instances for equality.  <a href="#a898f036d2ff09cd028f0796b91c716ab">More...</a><br /></td></tr>
<tr class="separator:a898f036d2ff09cd028f0796b91c716ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f4c9e32f9712d2d4cca141ac1cff34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1Module.html#a44f4c9e32f9712d2d4cca141ac1cff34">operator!=</a> (const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a44f4c9e32f9712d2d4cca141ac1cff34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instances are different.  <a href="#a44f4c9e32f9712d2d4cca141ac1cff34">More...</a><br /></td></tr>
<tr class="separator:a44f4c9e32f9712d2d4cca141ac1cff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The public API of all modules. </p>
<p>Developers implement classes that derive from <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a>. <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> acts as a PIMPL (a <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instance is hidden inside the ModulePIMPL class) decoupling the algorithm details from the API. Users of the SDE interact with the algorithm through the common API implemented by the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class.</p>
<p>The state of the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class is divided in two. The first set of state is referred to as the algorithm's state and includes the list of allowed inputs, values of bound inputs, a list of all callback points, values of the submodules bound to those callback points, and the list of all possible results. This is state that is directly accessed during the execution of the algorithm, hence the name. The second set of state is termed module state and is needed by the SDE framework to correctly use the module. This state is not accessible (nor relevant) once the module is running. For the most part users will only be interested in algorithm state. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a155f4cf9a94036661914ffd445704b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155f4cf9a94036661914ffd445704b56">&#9670;&nbsp;</a></span>Module() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sde::Module::Module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a module with no implementation. </p>
<p>The <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instance resulting from this ctor wraps no algorithm, has no description, and is not locked. The only way to make the instance have an algorithm is to assign to it from an instance that already has an algorithm. In general working <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instances will be made by the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> and the only reason to make a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instance without an algorithm is as a placeholder.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acef87458ab633dd06bce9203cd65e9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef87458ab633dd06bce9203cd65e9fc">&#9670;&nbsp;</a></span>Module() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sde::Module::Module </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializing this <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> with a deep copy of <code>rhs</code>. </p>
<p>This ctor will make a deep copy of <code>rhs</code>. The resulting <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instance will have the same state. Of note this includes locked-ness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to deep copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>rhs</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1e46b6c0091271d5e1646c5392f5801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e46b6c0091271d5e1646c5392f5801">&#9670;&nbsp;</a></span>Module() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::Module::Module </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1Module.html">Module</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes this <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> with <code>rhs's</code> state. </p>
<p>This ctor will take ownership of <code>rhs's</code> state. The resulting instance will have the same state, including locked-ness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to take the state of. After this function call <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dcc9542daf09edb856d3a3a4c267706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dcc9542daf09edb856d3a3a4c267706">&#9670;&nbsp;</a></span>Module() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::Module::Module </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &gt;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> with the provided implementation. </p>
<p>This ctor will create a new <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instance which is implemented by the provided implementation. This ctor is largely intended to be used for creating lambda modules or other "one-off" types of modules because it does <b>not</b> associate a cache with the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a>. To associate a cache with the module one must use the ctor that takes a pointer to a ModulePIMPL instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>The implementation the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> should use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the PIMPL for the resulting instance. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8964c3cfaa22ab0422bd8bc85d6e8f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8964c3cfaa22ab0422bd8bc85d6e8f95">&#9670;&nbsp;</a></span>Module() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::Module::Module </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1Module.html#a7132ef4b522f5f4c09bead25f6ab8646">pimpl_ptr</a>&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Instantiates a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> with the provided backend. </p>
<p>This ctor is primarily designed to be used by the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a>; however, it can also be used by consumers who do not want to use the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The backend and state that will be used to implement this module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b5a7a0a6c860820f9eeb401914d0592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5a7a0a6c860820f9eeb401914d0592">&#9670;&nbsp;</a></span>~Module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::Module::~Module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard destructor. </p>
<p>After this call the cache and results may still persist depending on whether or not their reference counts went to zero upon deletion. Of note the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> usually holds a shared_ptr to the cache and the cache usually holds one to the result.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5eb265bd57b5f5cda1bf045e9178951a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb265bd57b5f5cda1bf045e9178951a">&#9670;&nbsp;</a></span>add_property_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sde::Module::add_property_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes the module satisfy the specified property type. </p>
<p>Each property type defines a series of inputs and results that a module must accept and compute. It is possible that a module satisfies a property type, but the module's developer did not register that the module satisfies that type. This function can be used to add additional property types to a module. Note that because a user can not add additional inputs or results to the module, the module must already satisfy the property type to be added. This function does not check if the module is capable of satisfying the provided property type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classsde_1_1PropertyType.html" title="Base class for defining the API a module uses to compute a particular property. ">PropertyType</a></td><td>The additional property type that this module should satisfy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this module does not have a backend or if the module is locked. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a629f560061c356e7075ab4c416d4ab4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629f560061c356e7075ab4c416d4ab4a">&#9670;&nbsp;</a></span>change_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void sde::Module::change_input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binds an input value to the specified input. </p>
<p>Inputs to a module can be set in one of two ways: by passing the inputs to run_as/run or by binding them to a module instance. This function is used to bind an input value to a module instance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of value being bound. Must be convertible to the type of the input field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The input whose value is being bound to <code>value</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new value of this input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the module's backend is not set or the module is locked, Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> does not correspond to an existing input. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>value</code> fails one or more bounds checks including being the wrong type. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa538341cce5d877936120604474e9aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa538341cce5d877936120604474e9aca">&#9670;&nbsp;</a></span>change_submod() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::Module::change_submod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsde_1_1Module.html">Module</a>&#160;</td>
          <td class="paramname"><em>new_mod</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the specified submodule to the provided module. </p>
<p>This overload will register the submodule <code>new_submod</code> under the key <code>key</code>. This overload is a convenience overload that is useful when the submodule is not stored in the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> or when the user wants to break aliasing. Most of the time, when the submodule is in the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> one wants to use the overload of this function which takes a shared_ptr in order to keep the connections synchronized.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key under which the module should be registered. <code>key</code> must be one of the keys defined by this module's implementation.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_mod</td><td>The module to register under the provided key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this module does not have an implementation or if it is locked, Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> does not correspond to a recognized callback. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>new_mod</code> does not satisfy the property type associated with <code>key</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to wrap <code>new_mod</code> in a shared_ptr. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7c38fd962301e08e8a9d4651ed929d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c38fd962301e08e8a9d4651ed929d19">&#9670;&nbsp;</a></span>change_submod() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sde::Module::change_submod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classsde_1_1Module.html">Module</a> &gt;&#160;</td>
          <td class="paramname"><em>new_module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows the user to change the submodule a module uses. </p>
<p>Each module maintains a list of callback points that it will use. Users can bind a particular module to a particular callback point using this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The callback point to bind the module to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">new_module</td><td>The module to bind to the callback point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the module does not have an implementation or if it is locked, Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> does not map to an existing callback point. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if <code>new_module</code> does not satisfy the requested property type. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62c56666e9d880dbc60debc43150e13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c56666e9d880dbc60debc43150e13f">&#9670;&nbsp;</a></span>citations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &gt; &amp; sde::Module::citations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of things to cite if you use the module. </p>
<p>We intend for most of the modules that are used with the SDE to be developed in an academic context. In those setting it's important to make sure credit is given where credit is due. This function will return a list of literature refrences that should be cited if you use this module.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of citations.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this module does not have an implementation set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e9ecb93f7030a7caf68648207f30090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9ecb93f7030a7caf68648207f30090">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &amp; sde::Module::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the human-readable description provided by the developer. </p>
<p>Developers are encouraged to provide human-readable descriptions of what their modules do. This description will be used as documentation. If the developer set a description then this function can be used to retrieve it.</p>
<dl class="section return"><dt>Returns</dt><dd>The description that the developer set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this module does not have an implementation. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_optional_access</td><td>if the description was not set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade8872f2ec304bad32aba270dcc85ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade8872f2ec304bad32aba270dcc85ebc">&#9670;&nbsp;</a></span>has_description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::Module::has_description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Did the module developer set a description for this module? </p>
<p>This function is used to determine if the developer has set the module's description.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the description has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the current module does not have an implementation. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9cc1f98ca7b000a584dd5909a552ec7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cc1f98ca7b000a584dd5909a552ec7a">&#9670;&nbsp;</a></span>has_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::Module::has_module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this module contain an implementation? </p>
<p>The <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> class is responsible for implementing most of this class. The <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> only takes <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instances and therefore always has modules with implementations; however, we allow users to default construct (and copy/move from default constructed instances) which means it is possible for a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> to not have an implementation. This function is used to check whether or not the current module has an implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the module has an implementation and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41f01f68786c435aa480abde606ecb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f01f68786c435aa480abde606ecb24">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sde::Module::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a hash of the module's state. </p>
<p>This function is used to compute a hash of the module's current state. This hash takes into account the currently bound inputs and submodules (including the states of those submodules). Note that memoization also needs to take into account the values of any additional inputs to run_as/run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The hasher instance to add the hash of the module to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If hashing any of the inputs throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c5154bc599ed119c31771ee2f13bc2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5154bc599ed119c31771ee2f13bc2f">&#9670;&nbsp;</a></span>inputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp; sde::Module::inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the inputs this module recognizes. </p>
<p>A module can have input values bound to it. Ultimately in order for the module to run all required inputs must have a value bound to them. These values come from two places those passed to the run_as/run function and those bound to the module. This function returns the set of all inputs that this module expects as well as any bound values.</p>
<p>This function is for read-only access. Use change_input to bind a value or modify an already bound value.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of inputs bound to this module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the implementation of this module has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ed2c33f43f1de79679cc2aaa613871f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ed2c33f43f1de79679cc2aaa613871f">&#9670;&nbsp;</a></span>list_not_ready()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1Module.html#a0eb2aa36bc63794a6cab2f58e579baf7">Module::not_ready_type</a> sde::Module::list_not_ready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;&#160;</td>
          <td class="paramname"><em>in_inputs</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of module state that is not "ready". </p>
<p>Calling <code>ready</code> is an easy way to determine if the module's <code>run</code> member can be called; however, if the module is not ready it can be a bit of a pain to figure out why. This function will return a map containing the reasons why the module is not ready. The keys of the map describe the part of the module that is not ready. Choices are:</p>
<ul>
<li>"Inputs" to indicate that one or more required inputs have not been set</li>
<li>"Submodules" to indicate that one or more submodules have not been set.</li>
</ul>
<p>For inputs and submodules, the value in the map is the set of input/submodule keys corresponding to the inputs/submodules that are not set yet.</p>
<p>Note that since some inputs will be provided via the property type it is possible for the module to be ready even if all the bound inputs are not. For this reason this function takes an optional list of inputs. These inputs are assumed to be part of the property type's API and will not be included in the value returned by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_inputs</td><td>The set of inputs provided by the property type. Defaults to an empty map. Values are not checked for ready-ness.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of this module's state that is not set yet.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the returned object. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the implementation of this module has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28bcc7a0e0af3088a3aa8da4525c1b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bcc7a0e0af3088a3aa8da4525c1b82">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sde::Module::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the module and all submodules. </p>
<p>A locked module can no longer have its inputs or submodules modified. This function will first lock all submodules (throwing if any of the submodules are not ready to be locked) and then lock the current module. Unlike the lock calls to the submodules, which know the type that the module will be run as, and can thus assert their readiness, this call does not know how the module will be run and will perform no such check for this module.</p>
<p>This call also locks all submodules</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std;:runtime_error</td><td>if a submodule is not ready. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a3e9324f7eb75d4b39bca2f15da34a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a3e9324f7eb75d4b39bca2f15da34a5">&#9670;&nbsp;</a></span>locked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::Module::locked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the current module locked? </p>
<p>A locked module can not have its state modified. This avoids situations that may invalidate memoization caused by an input changing after the memoization check occurred. This function is used to determine if the current module is locked or not.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the module is locked and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44f4c9e32f9712d2d4cca141ac1cff34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44f4c9e32f9712d2d4cca141ac1cff34">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::Module::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instances are different. </p>
<p>Two modules are equivalent if they contain the same algorithm (determined by comparing the <code>base</code> member), they have the same bound inputs, the same bound set of submodules, the same lockedness, and satisfy the same property types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the instances are equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the base comparison throws or if any of the input comparisons throw. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b87712b71a3e9fb1796ef4cf75d725d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b87712b71a3e9fb1796ef4cf75d725d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1Module.html">Module</a> &amp; sde::Module::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets this <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a>'s state to a deep copy of <code>rhs</code>. </p>
<p>This function will set the current instance's state to a deep copy of <code>rhs's</code> state. The resulting <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> have the same state as <code>rhs</code> including lockedness. Memory associated with the old state will be freed up and references will thus become invalid. The notable exception is the cache and the results in it, which will only be freed if they are not also in use elsewhere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to deep copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance set to a deep copy of <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>rhs</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd94d82a291ab243a3031897005666fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd94d82a291ab243a3031897005666fd">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1Module.html">Module</a> &amp; sde::Module::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1Module.html">Module</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a>'s state to <code>rhs's</code> state. </p>
<p>This function will set the current instance's state to <code>rhs's</code> state. The resulting <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> will have the same state as <code>rhs</code> including lockedness. Memory associated with the old state will be freed up and references will thus become invalid. The notable exception is the cache and the results in it, which will only be freed if they are not also in use elsewhere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to take the state of. After this operation <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance, now with <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a898f036d2ff09cd028f0796b91c716ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898f036d2ff09cd028f0796b91c716ab">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::Module::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instances for equality. </p>
<p>Two modules are equivalent if they contain the same algorithm (determined by comparing the <code>base</code> member), they have the same bound inputs, the same bound set of submodules, the same lockedness, and satisfy the same property types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the instances are equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the base comparison throws or if any of the input comparisons throw. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49a27e835cc714d439c3feb88e11ff6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a27e835cc714d439c3feb88e11ff6a">&#9670;&nbsp;</a></span>profile_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string sde::Module::profile_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns timing data for this module and all submodules. </p>
<p>Each time the run member is called the time for the call (including all SDE overhead) is recorded. This also occurs for all calls to submodules' run members. This function creates a formatted string with this module's timing data, including the breakdown in terms of submodule calls.</p>
<dl class="section return"><dt>Returns</dt><dd>All timing data collected for this module and its submodules as a formatted string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there's insufficient memory to allocate the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c88c7417c8a6e01a08da71bcd5857da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c88c7417c8a6e01a08da71bcd5857da">&#9670;&nbsp;</a></span>property_types()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="namespacesde_1_1type.html#a57864c40693cc764558896980ab0be01">type::rtti</a> &gt; &amp; sde::Module::property_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of property types that this module can be run as. </p>
<p>The SDE will only run a module as a whitelisted property type. When a developer specifies that a module satisfies a particular property type that property type gets whitelisted. It is also possible for the user to specify additional property types that a module satisfies. Since the user can not modify the sets of inputs/results that the module takes/computes adding additional property types only makes sense if the module already satisfies the property type, but the developer did not say so. Regardless, this function can be used to retrieve the set of property types that this module can be run as.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of property types that this module satisfies.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this instance does not have an implementation. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab29fbfa743e082354cafa6151d538a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab29fbfa743e082354cafa6151d538a6">&#9670;&nbsp;</a></span>ready() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PropertyType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sde::Module::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this module is ready to be run as the provided property type. </p>
<p>This function is equivalent to calling <code>list_not_ready</code> and with the inputs provided by property type <code><a class="el" href="classsde_1_1PropertyType.html" title="Base class for defining the API a module uses to compute a particular property. ">PropertyType</a></code> and returning whether or not the returned list is empty.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="classsde_1_1PropertyType.html" title="Base class for defining the API a module uses to compute a particular property. ">PropertyType</a></td><td>The property type we want to know if the module can be run as.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the module is ready to be run as <code><a class="el" href="classsde_1_1PropertyType.html" title="Base class for defining the API a module uses to compute a particular property. ">PropertyType</a></code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if an implementation has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if <code>list_not_ready</code> has insufficient memory. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a55ce7c4d91ee1c093b6197d2441fc2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ce7c4d91ee1c093b6197d2441fc2aa">&#9670;&nbsp;</a></span>ready() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::Module::ready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;&#160;</td>
          <td class="paramname"><em>inps</em> = <code><a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if this module is ready to be run given the inputs provided. </p>
<p>This function is equivalent to calling <code>list_not_ready</code> and with the inputs provided and returning whether or not the returned list is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inps</td><td>The inputs to forward to list_not_ready.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the module can be run given the inputs provided in <code>inps</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if an implementation has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if <code>list_not_ready</code> has insufficient memory. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dece772a6a9c5b1e2903b9c24445e45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dece772a6a9c5b1e2903b9c24445e45">&#9670;&nbsp;</a></span>results()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a> &amp; sde::Module::results </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the set of results that can be computed by this module. </p>
<p>The set of results that a module can compute is the union of the set of results each property type can compute with the set of additional results that the developer specified. This function will return the set of results that a module can compute. The resulting set will not contain any actual results, but rather simply serves as a list of what can be computed.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of results that this module can compute.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if no implementation has been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a758b7d9c7154626ea11d898dec192f56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758b7d9c7154626ea11d898dec192f56">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a> sde::Module::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a>&#160;</td>
          <td class="paramname"><em>ps</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The advanced API for running the module. </p>
<p>This member allows you to set whatever inputs you would like and gives you access to all of the results. This flexibility comes at the cost of loosing compile-time type checking. The result is that if you provide an input with an object of the incorrect type or try to cast an output to an incompatible type this will only be detected as an error at runtime. All inputs will still be checked for domain errors per usual.</p>
<p>This function is primarily intended for use by developers who for whatever reason need to provide/access inputs/results that are not part of a property type. In most scenarios the use of this function signals the accrual of technical debt resulting from code coupling. The technical debt can be avoided by creating/modifying a property type so that it takes/returns the additional inputs/results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>A list of inputs and the values to bind to them.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map from output keys to that output's value.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the module does not have an implementation, the provided inputs are not ready, or if the module is not ready. Strong throw guarantee.</td></tr>
    <tr><td class="paramname">???</td><td>If the underlying algorithm throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afffa0771774b59785bf8270679ef27a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afffa0771774b59785bf8270679ef27a4">&#9670;&nbsp;</a></span>run_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename property_type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sde::Module::run_as </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The primary API for running the encapsulated code. </p>
<p>When a user runs a module they typically go through this API. The input to this API are the property type to run the module as and the inputs defined by the property type. The results are the results defined by the property type.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">property_type</td><td>The class codifying the property type that the module should be run as. An error will be raised if the module does not satisfy that property type. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the input arguments. Must be implicitly convertible to the input types defined by the property type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The input values that will be forwarded to the module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the results defined by the property type.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the module does not have an implementation, the provided inputs are not ready, if the module is not ready, or if the module is not of the specified property type. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc1aedde11932b2ba7781a17b15080b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1aedde11932b2ba7781a17b15080b6">&#9670;&nbsp;</a></span>submods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#a347228253f8054a46b3c53da07e7890b">type::submodule_map</a> &amp; sde::Module::submods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the submodule callback points defined by this module. </p>
<p>Modules may define callback points where they will call other modules to compute an intermediate result. Associated with each of these callback points is a <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a>. This function can be used to retrieve the list of submodule callback points defined by this module as well as which submodule is bound to that callback point.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of submodule requests defined by this module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the implementation of this module has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48a97eb40f323f9df8b95aefdfb69c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a97eb40f323f9df8b95aefdfb69c3d">&#9670;&nbsp;</a></span>unlocked_copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1Module.html">Module</a> sde::Module::unlocked_copy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an unlocked deep copy of this module. </p>
<p>The copy ctor copies all aspects of the module including lockedness. If you want to change the state of a locked module you need to make an unlocked copy. This function will do that for you.</p>
<dl class="section return"><dt>Returns</dt><dd>An unlocked deep copy of this module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the copy ctor throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sde/<a class="el" href="module_8hpp_source.html">module.hpp</a></li>
<li>sde/module.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
