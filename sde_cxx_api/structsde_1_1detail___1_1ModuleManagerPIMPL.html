<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sde: sde::detail_::ModuleManagerPIMPL Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sde</b></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="structsde_1_1detail___1_1ModuleManagerPIMPL-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sde::detail_::ModuleManagerPIMPL Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class that implements the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a>.  
 <a href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="module__manager__pimpl_8hpp_source.html">module_manager_pimpl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a657391b536367b6c1ee3fe7f64c3a836"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a657391b536367b6c1ee3fe7f64c3a836">module_base_ptr</a> = std::shared_ptr&lt; const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &gt;</td></tr>
<tr class="separator:a657391b536367b6c1ee3fe7f64c3a836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addadef254430d2df3c041793c5f80a21"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#addadef254430d2df3c041793c5f80a21">base_map</a> = std::map&lt; std::type_index, <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a657391b536367b6c1ee3fe7f64c3a836">module_base_ptr</a> &gt;</td></tr>
<tr class="separator:addadef254430d2df3c041793c5f80a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fbcb99e18fac998b7a472af31c343c"><td class="memItemLeft" align="right" valign="top"><a id="aa1fbcb99e18fac998b7a472af31c343c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#aa1fbcb99e18fac998b7a472af31c343c">shared_module</a> = std::shared_ptr&lt; <a class="el" href="classsde_1_1Module.html">Module</a> &gt;</td></tr>
<tr class="memdesc:aa1fbcb99e18fac998b7a472af31c343c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a usable module. <br /></td></tr>
<tr class="separator:aa1fbcb99e18fac998b7a472af31c343c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb19701867178628de843fc1b0513b8d"><td class="memItemLeft" align="right" valign="top"><a id="acb19701867178628de843fc1b0513b8d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#acb19701867178628de843fc1b0513b8d">module_map</a> = utilities::CaseInsensitiveMap&lt; std::shared_ptr&lt; <a class="el" href="classsde_1_1Module.html">Module</a> &gt; &gt;</td></tr>
<tr class="memdesc:acb19701867178628de843fc1b0513b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map holding usable modules. <br /></td></tr>
<tr class="separator:acb19701867178628de843fc1b0513b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f2e16f741f1d83de7d818194e86f87"><td class="memItemLeft" align="right" valign="top"><a id="ac5f2e16f741f1d83de7d818194e86f87"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#ac5f2e16f741f1d83de7d818194e86f87">cache_type</a> = typename <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a4477aedb58a487a30676b7cf4947549d">ModulePIMPL::cache_type</a></td></tr>
<tr class="memdesc:ac5f2e16f741f1d83de7d818194e86f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a cache. <br /></td></tr>
<tr class="separator:ac5f2e16f741f1d83de7d818194e86f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bf7be8e694c5a016febb81f38046da"><td class="memItemLeft" align="right" valign="top"><a id="aa9bf7be8e694c5a016febb81f38046da"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#aa9bf7be8e694c5a016febb81f38046da">shared_cache</a> = std::shared_ptr&lt; <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#ac5f2e16f741f1d83de7d818194e86f87">cache_type</a> &gt;</td></tr>
<tr class="memdesc:aa9bf7be8e694c5a016febb81f38046da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a shared cache. <br /></td></tr>
<tr class="separator:aa9bf7be8e694c5a016febb81f38046da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e298d3c581e839a787f1b85d0d1fd96"><td class="memItemLeft" align="right" valign="top"><a id="a5e298d3c581e839a787f1b85d0d1fd96"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a5e298d3c581e839a787f1b85d0d1fd96">cache_map</a> = std::map&lt; std::type_index, <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#aa9bf7be8e694c5a016febb81f38046da">shared_cache</a> &gt;</td></tr>
<tr class="memdesc:a5e298d3c581e839a787f1b85d0d1fd96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map holding caches. <br /></td></tr>
<tr class="separator:a5e298d3c581e839a787f1b85d0d1fd96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085dab52c86b8d3866dfdb7dfac12454"><td class="memItemLeft" align="right" valign="top"><a id="a085dab52c86b8d3866dfdb7dfac12454"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a085dab52c86b8d3866dfdb7dfac12454">default_map</a> = std::map&lt; std::type_index, <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &gt;</td></tr>
<tr class="memdesc:a085dab52c86b8d3866dfdb7dfac12454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a map holding the default module key for a given property type. <br /></td></tr>
<tr class="separator:a085dab52c86b8d3866dfdb7dfac12454"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae7acc32dfece5b4faea9806edef2d145"><td class="memItemLeft" align="right" valign="top"><a id="ae7acc32dfece5b4faea9806edef2d145"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#ae7acc32dfece5b4faea9806edef2d145">clone</a> ()</td></tr>
<tr class="memdesc:ae7acc32dfece5b4faea9806edef2d145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of this instance on the heap. <br /></td></tr>
<tr class="separator:ae7acc32dfece5b4faea9806edef2d145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91417df534f7d124cc3c1fb4a62e3ac1"><td class="memItemLeft" align="right" valign="top"><a id="a91417df534f7d124cc3c1fb4a62e3ac1"></a>
<a class="el" href="namespacesde_1_1type.html#a8ea5d692491ba6f4f58c376cb789ceb7">type::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a91417df534f7d124cc3c1fb4a62e3ac1">count</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key) const noexcept</td></tr>
<tr class="memdesc:a91417df534f7d124cc3c1fb4a62e3ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures we determine if we have a module consistently. <br /></td></tr>
<tr class="separator:a91417df534f7d124cc3c1fb4a62e3ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4896504575ad1b726ea5b7a4d89cc50d"><td class="memItemLeft" align="right" valign="top"><a id="a4896504575ad1b726ea5b7a4d89cc50d"></a>
<a class="el" href="namespacesde_1_1type.html#a8ea5d692491ba6f4f58c376cb789ceb7">type::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a4896504575ad1b726ea5b7a4d89cc50d">size</a> () const noexcept</td></tr>
<tr class="memdesc:a4896504575ad1b726ea5b7a4d89cc50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures we count the number of modules consistently. <br /></td></tr>
<tr class="separator:a4896504575ad1b726ea5b7a4d89cc50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a77d9c73d9cd882acc9274c644e3e1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a1a77d9c73d9cd882acc9274c644e3e1e">set_default</a> (const std::type_info &amp;type, <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> inputs, <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> key)</td></tr>
<tr class="memdesc:a1a77d9c73d9cd882acc9274c644e3e1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default module to use for a given property type.  <a href="#a1a77d9c73d9cd882acc9274c644e3e1e">More...</a><br /></td></tr>
<tr class="separator:a1a77d9c73d9cd882acc9274c644e3e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae82634727c7296f161aaf7722d54fa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#aae82634727c7296f161aaf7722d54fa3">add_module</a> (<a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> key, <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a657391b536367b6c1ee3fe7f64c3a836">module_base_ptr</a> base)</td></tr>
<tr class="memdesc:aae82634727c7296f161aaf7722d54fa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function actually adds a module to the list of available modules.  <a href="#aae82634727c7296f161aaf7722d54fa3">More...</a><br /></td></tr>
<tr class="separator:aae82634727c7296f161aaf7722d54fa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b5d9b4baff252a2804a968d81e2d1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#ab0b5d9b4baff252a2804a968d81e2d1c">copy_module</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;old_key, <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> new_key)</td></tr>
<tr class="memdesc:ab0b5d9b4baff252a2804a968d81e2d1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a deep copy of a module.  <a href="#ab0b5d9b4baff252a2804a968d81e2d1c">More...</a><br /></td></tr>
<tr class="separator:ab0b5d9b4baff252a2804a968d81e2d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977158e524f5608ab6d3cbedeb29bc62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#aa1fbcb99e18fac998b7a472af31c343c">shared_module</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a977158e524f5608ab6d3cbedeb29bc62">at</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:a977158e524f5608ab6d3cbedeb29bc62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a module, filling in all non-set submodules with defaults if a ready default exists.  <a href="#a977158e524f5608ab6d3cbedeb29bc62">More...</a><br /></td></tr>
<tr class="separator:a977158e524f5608ab6d3cbedeb29bc62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Comparison operators</div></td></tr>
<tr class="memitem:a72ffd6f035f6cbe943fb4937c2c9244f"><td class="memItemLeft" align="right" valign="top"><a id="a72ffd6f035f6cbe943fb4937c2c9244f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a> &amp;rhs) const</td></tr>
<tr class="separator:a72ffd6f035f6cbe943fb4937c2c9244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef86667cb4207b9c25c1a522be7a6047"><td class="memItemLeft" align="right" valign="top"><a id="aef86667cb4207b9c25c1a522be7a6047"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html">ModuleManagerPIMPL</a> &amp;rhs) const</td></tr>
<tr class="separator:aef86667cb4207b9c25c1a522be7a6047"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">ModuleManager state</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The members in this section are the state of the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> class. </p>
</div></td></tr>
<tr class="memitem:af5af2b69475d346ab9937a026a6e1911"><td class="memItemLeft" align="right" valign="top"><a id="af5af2b69475d346ab9937a026a6e1911"></a>
<a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#addadef254430d2df3c041793c5f80a21">base_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_bases</b></td></tr>
<tr class="separator:af5af2b69475d346ab9937a026a6e1911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed9e1f6be4283ccfeaf53019baacd92"><td class="memItemLeft" align="right" valign="top"><a id="afed9e1f6be4283ccfeaf53019baacd92"></a>
<a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#acb19701867178628de843fc1b0513b8d">module_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_modules</b></td></tr>
<tr class="separator:afed9e1f6be4283ccfeaf53019baacd92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab764086e1e1865a4148ce91bd1624b78"><td class="memItemLeft" align="right" valign="top"><a id="ab764086e1e1865a4148ce91bd1624b78"></a>
<a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a5e298d3c581e839a787f1b85d0d1fd96">cache_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_caches</b></td></tr>
<tr class="separator:ab764086e1e1865a4148ce91bd1624b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acb84e938fabace250b3e1a26a9c7c6"><td class="memItemLeft" align="right" valign="top"><a id="a5acb84e938fabace250b3e1a26a9c7c6"></a>
<a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a085dab52c86b8d3866dfdb7dfac12454">default_map</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_defaults</b></td></tr>
<tr class="separator:a5acb84e938fabace250b3e1a26a9c7c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933edfb085454ed2ce593e1bba2962b2"><td class="memItemLeft" align="right" valign="top"><a id="a933edfb085454ed2ce593e1bba2962b2"></a>
std::map&lt; std::type_index, <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_inputs</b></td></tr>
<tr class="separator:a933edfb085454ed2ce593e1bba2962b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class that implements the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a>. </p>
<p>Users are expected to go through the API provided by the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> class. Inside the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> class calls are redirected to this class. When using this class calls should go through the member functions as much as possible so that error checking occurs. That said members are public so that it is easier to test the implementation. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="addadef254430d2df3c041793c5f80a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addadef254430d2df3c041793c5f80a21">&#9670;&nbsp;</a></span>base_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#addadef254430d2df3c041793c5f80a21">sde::detail_::ModuleManagerPIMPL::base_map</a> =  std::map&lt;std::type_index, <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a657391b536367b6c1ee3fe7f64c3a836">module_base_ptr</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a map from the module implementation's type to the implementation </p>

</div>
</div>
<a id="a657391b536367b6c1ee3fe7f64c3a836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657391b536367b6c1ee3fe7f64c3a836">&#9670;&nbsp;</a></span>module_base_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a657391b536367b6c1ee3fe7f64c3a836">sde::detail_::ModuleManagerPIMPL::module_base_ptr</a> =  std::shared_ptr&lt;const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of a pointer to a module's implemenation </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aae82634727c7296f161aaf7722d54fa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae82634727c7296f161aaf7722d54fa3">&#9670;&nbsp;</a></span>add_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModuleManagerPIMPL::add_module </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#a657391b536367b6c1ee3fe7f64c3a836">module_base_ptr</a>&#160;</td>
          <td class="paramname"><em>base</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function actually adds a module to the list of available modules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key under which the module will be registered. </td></tr>
    <tr><td class="paramname">base</td><td>The instance containing the algorithm </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a977158e524f5608ab6d3cbedeb29bc62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977158e524f5608ab6d3cbedeb29bc62">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structsde_1_1detail___1_1ModuleManagerPIMPL.html#aa1fbcb99e18fac998b7a472af31c343c">shared_module</a> sde::detail_::ModuleManagerPIMPL::at </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a module, filling in all non-set submodules with defaults if a ready default exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The module you want </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A shared_ptr to the requested module </dd></dl>

</div>
</div>
<a id="ab0b5d9b4baff252a2804a968d81e2d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b5d9b4baff252a2804a968d81e2d1c">&#9670;&nbsp;</a></span>copy_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModuleManagerPIMPL::copy_module </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>old_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a>&#160;</td>
          <td class="paramname"><em>new_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a deep copy of a module. </p>
<p>This function makes a deep copy of a module. The new module is unlocked regardless of whether the old module was locked or not. The user can call lock on the resulting module to make an exact copy </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_key</td><td>The key for the module to copy </td></tr>
    <tr><td class="paramname">new_key</td><td>The key under which the new module will live </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a77d9c73d9cd882acc9274c644e3e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a77d9c73d9cd882acc9274c644e3e1e">&#9670;&nbsp;</a></span>set_default()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModuleManagerPIMPL::set_default </td>
          <td>(</td>
          <td class="paramtype">const std::type_info &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a>&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default module to use for a given property type. </p>
<p>When a user requests a module that module initially has no submodules set unless the user has bound some to that module. Instead, the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> is now responsible to provide the module with submodules using the defaults. This function allows one to specify what the defaults are.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of the property type this default is for </td></tr>
    <tr><td class="paramname">key</td><td>The module key for the module to use as the default </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>sde/detail_/<a class="el" href="module__manager__pimpl_8hpp_source.html">module_manager_pimpl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
