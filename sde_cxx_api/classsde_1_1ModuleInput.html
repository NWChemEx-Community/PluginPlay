<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sde: sde::ModuleInput Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sde</b></li><li class="navelem"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsde_1_1ModuleInput-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sde::ModuleInput Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Holds an input value for a module in a type-erased form.  
 <a href="classsde_1_1ModuleInput.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="module__input_8hpp_source.html">module_input.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aaa0a0bb8bfc2304651110cc7d572eb52"><td class="memItemLeft" align="right" valign="top"><a id="aaa0a0bb8bfc2304651110cc7d572eb52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#aaa0a0bb8bfc2304651110cc7d572eb52">bounds_check_desc_t</a> = std::set&lt; <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &gt;</td></tr>
<tr class="memdesc:aaa0a0bb8bfc2304651110cc7d572eb52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a container containing the bounds check descriptions. <br /></td></tr>
<tr class="separator:aaa0a0bb8bfc2304651110cc7d572eb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8e273d9577a3979155f364b8478078"><td class="memTemplParams" colspan="2"><a id="afa8e273d9577a3979155f364b8478078"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa8e273d9577a3979155f364b8478078"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#afa8e273d9577a3979155f364b8478078">validity_check</a> = std::function&lt; bool(const T &amp;)&gt;</td></tr>
<tr class="memdesc:afa8e273d9577a3979155f364b8478078"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a functor that can be used to check a value. <br /></td></tr>
<tr class="separator:afa8e273d9577a3979155f364b8478078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0e3f9bff381f62d9fa6a806f9d6697"><td class="memItemLeft" align="right" valign="top"><a id="a4a0e3f9bff381f62d9fa6a806f9d6697"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a4a0e3f9bff381f62d9fa6a806f9d6697">any_check</a> = <a class="el" href="classsde_1_1ModuleInput.html#afa8e273d9577a3979155f364b8478078">validity_check</a>&lt; <a class="el" href="namespacesde_1_1type.html#add3c0d2e31e0988ac4b9fdc68bc0cdda">type::any</a> &gt;</td></tr>
<tr class="memdesc:a4a0e3f9bff381f62d9fa6a806f9d6697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a check that operates on a type-erased value. <br /></td></tr>
<tr class="separator:a4a0e3f9bff381f62d9fa6a806f9d6697"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a530f7cd74551eb6f767c7fde0a160917"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a530f7cd74551eb6f767c7fde0a160917">ModuleInput</a> ()</td></tr>
<tr class="memdesc:a530f7cd74551eb6f767c7fde0a160917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new, null <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instance.  <a href="#a530f7cd74551eb6f767c7fde0a160917">More...</a><br /></td></tr>
<tr class="separator:a530f7cd74551eb6f767c7fde0a160917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc0ef0c7eb4f797757c4e7831c0412b"><td class="memItemLeft" align="right" valign="top"><a id="a2dc0ef0c7eb4f797757c4e7831c0412b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ModuleInput</b> (const <a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;rhs)</td></tr>
<tr class="separator:a2dc0ef0c7eb4f797757c4e7831c0412b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fe01911171d0524a88a83204270528"><td class="memItemLeft" align="right" valign="top"><a id="a79fe01911171d0524a88a83204270528"></a>
<a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;rhs)</td></tr>
<tr class="separator:a79fe01911171d0524a88a83204270528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740715b6e6a7b5748b7f74c452cbd4cc"><td class="memItemLeft" align="right" valign="top"><a id="a740715b6e6a7b5748b7f74c452cbd4cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ModuleInput</b> (<a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:a740715b6e6a7b5748b7f74c452cbd4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7669dfb880d3f7d32bdafc3f662d92"><td class="memItemLeft" align="right" valign="top"><a id="afc7669dfb880d3f7d32bdafc3f662d92"></a>
<a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:afc7669dfb880d3f7d32bdafc3f662d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa161506776a0ec041783364496a1931a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#aa161506776a0ec041783364496a1931a">~ModuleInput</a> () noexcept</td></tr>
<tr class="memdesc:aa161506776a0ec041783364496a1931a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard destructor.  <a href="#aa161506776a0ec041783364496a1931a">More...</a><br /></td></tr>
<tr class="separator:aa161506776a0ec041783364496a1931a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebde34fbab7a754359bbcbbdc948c9fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#aebde34fbab7a754359bbcbbdc948c9fd">has_type</a> () const noexcept</td></tr>
<tr class="memdesc:aebde34fbab7a754359bbcbbdc948c9fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the type of this field been set yet?  <a href="#aebde34fbab7a754359bbcbbdc948c9fd">More...</a><br /></td></tr>
<tr class="separator:aebde34fbab7a754359bbcbbdc948c9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c865e63d1143679c2e89c2ccced4a10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a4c865e63d1143679c2e89c2ccced4a10">has_value</a> () const noexcept</td></tr>
<tr class="memdesc:a4c865e63d1143679c2e89c2ccced4a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this input field have a value bound to it.  <a href="#a4c865e63d1143679c2e89c2ccced4a10">More...</a><br /></td></tr>
<tr class="separator:a4c865e63d1143679c2e89c2ccced4a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c814826704e16dbf8beb905aaa6427"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a31c814826704e16dbf8beb905aaa6427">has_description</a> () const noexcept</td></tr>
<tr class="memdesc:a31c814826704e16dbf8beb905aaa6427"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the description of this input field been set?  <a href="#a31c814826704e16dbf8beb905aaa6427">More...</a><br /></td></tr>
<tr class="separator:a31c814826704e16dbf8beb905aaa6427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e9bf55ba5c9081c3005161e764bfbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#af3e9bf55ba5c9081c3005161e764bfbf">is_optional</a> () const noexcept</td></tr>
<tr class="memdesc:af3e9bf55ba5c9081c3005161e764bfbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must a value be bound to this input before it can be used?  <a href="#af3e9bf55ba5c9081c3005161e764bfbf">More...</a><br /></td></tr>
<tr class="separator:af3e9bf55ba5c9081c3005161e764bfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a26809791a5d0e31dd83af1385ac204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a9a26809791a5d0e31dd83af1385ac204">is_transparent</a> () const noexcept</td></tr>
<tr class="memdesc:a9a26809791a5d0e31dd83af1385ac204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this input influence memoization?  <a href="#a9a26809791a5d0e31dd83af1385ac204">More...</a><br /></td></tr>
<tr class="separator:a9a26809791a5d0e31dd83af1385ac204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112870c5b5a2fe0cb51a1154f222c55e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a112870c5b5a2fe0cb51a1154f222c55e">ready</a> () const noexcept</td></tr>
<tr class="memdesc:a112870c5b5a2fe0cb51a1154f222c55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if an input value is ready to be given to a module.  <a href="#a112870c5b5a2fe0cb51a1154f222c55e">More...</a><br /></td></tr>
<tr class="separator:a112870c5b5a2fe0cb51a1154f222c55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950bdb624635ad32c70a2e3a6cb508a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a950bdb624635ad32c70a2e3a6cb508a9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a950bdb624635ad32c70a2e3a6cb508a9">is_valid</a> (T &amp;&amp;new_value) const</td></tr>
<tr class="memdesc:a950bdb624635ad32c70a2e3a6cb508a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the provided value is a valid value.  <a href="#a950bdb624635ad32c70a2e3a6cb508a9">More...</a><br /></td></tr>
<tr class="separator:a950bdb624635ad32c70a2e3a6cb508a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba286a1369a139d028c22418c5982317"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#aba286a1369a139d028c22418c5982317">hash</a> (<a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;h) const</td></tr>
<tr class="memdesc:aba286a1369a139d028c22418c5982317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the current instance and adds the hash to the provided hasher object.  <a href="#aba286a1369a139d028c22418c5982317">More...</a><br /></td></tr>
<tr class="separator:aba286a1369a139d028c22418c5982317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6aae204852da96421a61b320c593126"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6aae204852da96421a61b320c593126"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#ac6aae204852da96421a61b320c593126">set_type</a> ()</td></tr>
<tr class="memdesc:ac6aae204852da96421a61b320c593126"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the type of this input field to <code>T</code>.  <a href="#ac6aae204852da96421a61b320c593126">More...</a><br /></td></tr>
<tr class="separator:ac6aae204852da96421a61b320c593126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c6ae975db995321c6091501685eecb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54c6ae975db995321c6091501685eecb"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a54c6ae975db995321c6091501685eecb">change</a> (T &amp;&amp;new_value)</td></tr>
<tr class="memdesc:a54c6ae975db995321c6091501685eecb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to change the value bound to this input field.  <a href="#a54c6ae975db995321c6091501685eecb">More...</a><br /></td></tr>
<tr class="separator:a54c6ae975db995321c6091501685eecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e0bf4ef13947fc82601e1b1003e57b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6e0bf4ef13947fc82601e1b1003e57b"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#ab6e0bf4ef13947fc82601e1b1003e57b">set_default</a> (T &amp;&amp;new_value)</td></tr>
<tr class="memdesc:ab6e0bf4ef13947fc82601e1b1003e57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Establishes the default value for the input field.  <a href="#ab6e0bf4ef13947fc82601e1b1003e57b">More...</a><br /></td></tr>
<tr class="separator:ab6e0bf4ef13947fc82601e1b1003e57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff93c991cdf0a842989a47cc21ee25b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a4ff93c991cdf0a842989a47cc21ee25b">set_description</a> (<a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> desc) noexcept</td></tr>
<tr class="memdesc:a4ff93c991cdf0a842989a47cc21ee25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the human-readable description of this input field to <code>desc</code>.  <a href="#a4ff93c991cdf0a842989a47cc21ee25b">More...</a><br /></td></tr>
<tr class="separator:a4ff93c991cdf0a842989a47cc21ee25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e284b6b2c96c175ce4afd10b4c4c47"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a41e284b6b2c96c175ce4afd10b4c4c47"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a41e284b6b2c96c175ce4afd10b4c4c47">add_check</a> (<a class="el" href="structsde_1_1bounds__checking_1_1CompareTo.html">bounds_checking::CompareTo</a>&lt; T, U &gt; check, <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> desc=&quot;&quot;)</td></tr>
<tr class="memdesc:a41e284b6b2c96c175ce4afd10b4c4c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for adding a pre-defined bounds check to the input.  <a href="#a41e284b6b2c96c175ce4afd10b4c4c47">More...</a><br /></td></tr>
<tr class="separator:a41e284b6b2c96c175ce4afd10b4c4c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0e69c2d21317f290b11361e40ea4df"><td class="memTemplParams" colspan="2"><a id="a2c0e69c2d21317f290b11361e40ea4df"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c0e69c2d21317f290b11361e40ea4df"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_check</b> (<a class="el" href="structsde_1_1bounds__checking_1_1InRange.html">bounds_checking::InRange</a>&lt; T &gt; check, <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> desc=&quot;&quot;)</td></tr>
<tr class="separator:a2c0e69c2d21317f290b11361e40ea4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c5d2e58ecb4445e3c39ae1207d1ad8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab1c5d2e58ecb4445e3c39ae1207d1ad8"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#ab1c5d2e58ecb4445e3c39ae1207d1ad8">add_check</a> (<a class="el" href="classsde_1_1ModuleInput.html#afa8e273d9577a3979155f364b8478078">validity_check</a>&lt; T &gt; check, <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> desc=&quot;&quot;)</td></tr>
<tr class="memdesc:ab1c5d2e58ecb4445e3c39ae1207d1ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for adding a custom bounds check to the input.  <a href="#ab1c5d2e58ecb4445e3c39ae1207d1ad8">More...</a><br /></td></tr>
<tr class="separator:ab1c5d2e58ecb4445e3c39ae1207d1ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931feb901f2ddfe98025b8c9ddda4783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a931feb901f2ddfe98025b8c9ddda4783">make_optional</a> () noexcept</td></tr>
<tr class="memdesc:a931feb901f2ddfe98025b8c9ddda4783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags the current input field as optional.  <a href="#a931feb901f2ddfe98025b8c9ddda4783">More...</a><br /></td></tr>
<tr class="separator:a931feb901f2ddfe98025b8c9ddda4783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af306efc6cc26213ab0cdec450f18edb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#af306efc6cc26213ab0cdec450f18edb3">make_required</a> () noexcept</td></tr>
<tr class="memdesc:af306efc6cc26213ab0cdec450f18edb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags the current input field as optional.  <a href="#af306efc6cc26213ab0cdec450f18edb3">More...</a><br /></td></tr>
<tr class="separator:af306efc6cc26213ab0cdec450f18edb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f043a8bfb2a3d4cbd1c233b9aac1fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a00f043a8bfb2a3d4cbd1c233b9aac1fb">make_opaque</a> () noexcept</td></tr>
<tr class="memdesc:a00f043a8bfb2a3d4cbd1c233b9aac1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags the current input field as opaque.  <a href="#a00f043a8bfb2a3d4cbd1c233b9aac1fb">More...</a><br /></td></tr>
<tr class="separator:a00f043a8bfb2a3d4cbd1c233b9aac1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0ebf269de9d592821b2f3b0136c560"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a6c0ebf269de9d592821b2f3b0136c560">make_transparent</a> () noexcept</td></tr>
<tr class="memdesc:a6c0ebf269de9d592821b2f3b0136c560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags the current input field as transparent.  <a href="#a6c0ebf269de9d592821b2f3b0136c560">More...</a><br /></td></tr>
<tr class="separator:a6c0ebf269de9d592821b2f3b0136c560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442883f639cbc815fec515543ad8ae19"><td class="memItemLeft" align="right" valign="top"><a id="a442883f639cbc815fec515543ad8ae19"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>str</b> () const</td></tr>
<tr class="separator:a442883f639cbc815fec515543ad8ae19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e82c688290e715cd047a4c224f29551"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e82c688290e715cd047a4c224f29551"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a3e82c688290e715cd047a4c224f29551">value</a> ()</td></tr>
<tr class="memdesc:a3e82c688290e715cd047a4c224f29551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bound input as an instance of type <code>T</code>.  <a href="#a3e82c688290e715cd047a4c224f29551">More...</a><br /></td></tr>
<tr class="separator:a3e82c688290e715cd047a4c224f29551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae2f9c8f8c5497c44b9ffd452ee7391"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ae2f9c8f8c5497c44b9ffd452ee7391"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a9ae2f9c8f8c5497c44b9ffd452ee7391">value</a> () const</td></tr>
<tr class="memdesc:a9ae2f9c8f8c5497c44b9ffd452ee7391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bound input as an instance of type <code>T</code>.  <a href="#a9ae2f9c8f8c5497c44b9ffd452ee7391">More...</a><br /></td></tr>
<tr class="separator:a9ae2f9c8f8c5497c44b9ffd452ee7391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed0650651df91fed62dd59128b18649"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a1ed0650651df91fed62dd59128b18649">description</a> () const</td></tr>
<tr class="memdesc:a1ed0650651df91fed62dd59128b18649"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description of the input field.  <a href="#a1ed0650651df91fed62dd59128b18649">More...</a><br /></td></tr>
<tr class="separator:a1ed0650651df91fed62dd59128b18649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c3718631aab56f362285c3d3bb8f5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1ModuleInput.html#aaa0a0bb8bfc2304651110cc7d572eb52">bounds_check_desc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a22c3718631aab56f362285c3d3bb8f5c">check_descriptions</a> () const</td></tr>
<tr class="memdesc:a22c3718631aab56f362285c3d3bb8f5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the descriptions of the bounds checks this input is subject to.  <a href="#a22c3718631aab56f362285c3d3bb8f5c">More...</a><br /></td></tr>
<tr class="separator:a22c3718631aab56f362285c3d3bb8f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2b3600d0a02288fee70ec3ca608163"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#afd2b3600d0a02288fee70ec3ca608163">operator==</a> (const <a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:afd2b3600d0a02288fee70ec3ca608163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instances for equality.  <a href="#afd2b3600d0a02288fee70ec3ca608163">More...</a><br /></td></tr>
<tr class="separator:afd2b3600d0a02288fee70ec3ca608163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1309dc0e48981471b9c299167ce0fef7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleInput.html#a1309dc0e48981471b9c299167ce0fef7">operator!=</a> (const <a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a1309dc0e48981471b9c299167ce0fef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instances are different.  <a href="#a1309dc0e48981471b9c299167ce0fef7">More...</a><br /></td></tr>
<tr class="separator:a1309dc0e48981471b9c299167ce0fef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Holds an input value for a module in a type-erased form. </p>
<p>When a module gets its input parameters they come as instances of this class. As part of its state, the <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> class contains an SDEAny instance, which wraps the value. The value can be retrieved via the <code>value</code> member, assuming the caller knows the correct type. In addition to the actual value, this class also stores various metadata about the input including:</p>
<ul>
<li>a description of what the input will be used for,</li>
<li>bounds checks that the value must satisfy,</li>
<li>if the value is optional (<em>i.e.</em>, the module works even if the value is not set),</li>
<li>if the value is transparent (<em>i.e.</em>, the vale does not change the output of the module, for example a printing threshold),</li>
</ul>
<p>Features:</p>
<p>Bounds Checking. Any time the value of the input is changed the new value is passed through each bounds check. If a bounds check fails, changing the value fails. This ensures that the input is always valid and prevents the module from having to do these checks manually. Minimally bounds checking will ensure that the value is of the correct type. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a530f7cd74551eb6f767c7fde0a160917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530f7cd74551eb6f767c7fde0a160917">&#9670;&nbsp;</a></span>ModuleInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sde::ModuleInput::ModuleInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a new, null <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instance. </p>
<p>The instance resulting from this call will have no type, value, or metadata (description, opaqueness, etc.). This data can be set using the class's provided setters.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the PIMPL instance. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa161506776a0ec041783364496a1931a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa161506776a0ec041783364496a1931a">&#9670;&nbsp;</a></span>~ModuleInput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::ModuleInput::~ModuleInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard destructor. </p>
<p>This deletes the state of the instance meaning that all references to the internal state, notably the value and the description, are invalidated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a41e284b6b2c96c175ce4afd10b4c4c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41e284b6b2c96c175ce4afd10b4c4c47">&#9670;&nbsp;</a></span>add_check() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::ModuleInput::add_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structsde_1_1bounds__checking_1_1CompareTo.html">bounds_checking::CompareTo</a>&lt; T, U &gt;&#160;</td>
          <td class="paramname"><em>check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a>&#160;</td>
          <td class="paramname"><em>desc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for adding a pre-defined bounds check to the input. </p>
<p>The SDE comes stocked with pre-defined bounds checks for a variety of situations. Developers are encouraged to use these bounds checks as they are self-documenting. This overload catches these pre-defined checks and ensures that appropriate documentation is generated for them. Developers can overwrite the autogenerated documentation by providing their own.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value the bounds check accepts. Must be implicitly convertible to the type of this input field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">check</td><td>The functor that performs the bounds check.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The description of what this check is checking. If empty a documentation string will be autogenerated. Default is empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> with its state modified to include <code>check</code> and <code>desc</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the input field contains a value and that value fails <code>check</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>if the bounds check throws. Same throw guarantee as the bounds check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c5d2e58ecb4445e3c39ae1207d1ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c5d2e58ecb4445e3c39ae1207d1ad8">&#9670;&nbsp;</a></span>add_check() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::ModuleInput::add_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1ModuleInput.html#afa8e273d9577a3979155f364b8478078">validity_check</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>check</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a>&#160;</td>
          <td class="paramname"><em>desc</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload for adding a custom bounds check to the input. </p>
<p>The SDE comes stocked with pre-defined bounds checks for a variety of situations. Developers are encouraged to use these bounds checks as they are self-documenting. This overload catches developer-defined checks. No documentation for the check will be generated unless the developer provides it.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value the bounds check accepts. Must be implicitly convertible to the type of this input field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">check</td><td>The functor that performs the bounds check.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The description of what this check is checking. Default is empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> with its state modified to include <code>check</code> and <code>desc</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the input field contains a value and that value fails <code>check</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>if the bounds check throws. Same throw guarantee as the bounds check. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54c6ae975db995321c6091501685eecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c6ae975db995321c6091501685eecb">&#9670;&nbsp;</a></span>change()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::ModuleInput::change </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to change the value bound to this input field. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_value</td><td>The value to bind to this input field. Must satisfy all bounds checks affiliated with this input field in order for this function to succeed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instance with the value bound to <code>new_value</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the type has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::inavalid_argument</td><td>if <code>new_value</code> fails any bounds checks. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22c3718631aab56f362285c3d3bb8f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c3718631aab56f362285c3d3bb8f5c">&#9670;&nbsp;</a></span>check_descriptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1ModuleInput.html#aaa0a0bb8bfc2304651110cc7d572eb52">ModuleInput::bounds_check_desc_t</a> sde::ModuleInput::check_descriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the descriptions of the bounds checks this input is subject to. </p>
<p>This function is intended to be used primarily for documentation purposes. It will return human-readable descriptions of each bounds check. To see if a value passes these bounds checks use <code>is_valid</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>A container with the descriptions.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficent memory to make the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ed0650651df91fed62dd59128b18649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed0650651df91fed62dd59128b18649">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &amp; sde::ModuleInput::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the description of the input field. </p>
<p>This function is used to retrieve the human-readable description of the input field (assuming one was set).</p>
<dl class="section return"><dt>Returns</dt><dd>A read-only reference to the input field.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if the description was not set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31c814826704e16dbf8beb905aaa6427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c814826704e16dbf8beb905aaa6427">&#9670;&nbsp;</a></span>has_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::has_description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the description of this input field been set? </p>
<p>Developers are encouraged to provide human-readable descriptions for each option detailing what that option is used for. These descriptions are then used as help strings.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the description of this input field has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebde34fbab7a754359bbcbbdc948c9fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebde34fbab7a754359bbcbbdc948c9fd">&#9670;&nbsp;</a></span>has_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::has_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the type of this field been set yet? </p>
<p>In order for an input field to be used with a module it needs to know what type it is wrapping. This function is used to determine if that type has been set yet.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the type of this field has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c865e63d1143679c2e89c2ccced4a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c865e63d1143679c2e89c2ccced4a10">&#9670;&nbsp;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::has_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this input field have a value bound to it. </p>
<p>At any given time an input field either has a value bound to it or does not. This function is used to determine if a value has been bound to this field.</p>
<dl class="section return"><dt>Returns</dt><dd>True if a value has been bound to this field and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba286a1369a139d028c22418c5982317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba286a1369a139d028c22418c5982317">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sde::ModuleInput::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes the current instance and adds the hash to the provided hasher object. </p>
<p>The current strategy for hashing in the SDE is to:</p>
<ul>
<li>make a hasher object,</li>
<li>pass it to everything you want to hash, and</li>
<li>finalize the hasher</li>
</ul>
<p>Upon finalization the hasher returns the hash of the collective state of objects passed to it. This function allows <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instances to be hashed by the hasher object. The present input will only be hashed if it is opaque.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The hasher object that is in the process of hashing stuff. If the current instance is opaque it will be added to <code>h's</code> internal state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the hash function for the wrapped value throws. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3e9bf55ba5c9081c3005161e764bfbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e9bf55ba5c9081c3005161e764bfbf">&#9670;&nbsp;</a></span>is_optional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::is_optional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Must a value be bound to this input before it can be used? </p>
<p>Typically a module needs every input to be set to a value before the module can be run. Sometimes, however, the module is capable of running even if an input has not been set. Examples of when this can occur include inputs controlling printing levels and inputs that represent hints or seeds for an algorithm. The unifying theme among these scenarios are that the module can default to reasonable behavior without values for these options. While usually it is possible to say default the value to 0, sometimes we need a null state separate from the possible input values and that is where the optional trait comes in.</p>
<p>This function is used to determine if the current input is optional</p>
<dl class="section return"><dt>Returns</dt><dd>True if the current input field is optional and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a26809791a5d0e31dd83af1385ac204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a26809791a5d0e31dd83af1385ac204">&#9670;&nbsp;</a></span>is_transparent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::is_transparent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this input influence memoization? </p>
<p>The SDE relies heavily on memoization in order to work. This is done automatically by hashing the inputs to a module. That said, sometimes an input to a module does not actually affect the result. A prototypical result is an input parameter controlling the debug print level. Inputs that do not affect memoization are termed "transparent". This function can be used to determine if an input is transparent or not.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the input is transparent and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a950bdb624635ad32c70a2e3a6cb508a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a950bdb624635ad32c70a2e3a6cb508a9">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::is_valid </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the provided value is a valid value. </p>
<p>This function will run all of the bounds checks on a value and return whether or not the provided value is a valid value, i.e., the value does not fail any bounds checks.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value we are checking</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_value</td><td>The value we are checking.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the provided value is a valid value and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the type of the input has not been set yet. Strong throw guarantee.</td></tr>
    <tr><td class="paramname">???</td><td>throws if any of the stored bounds checks through. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a00f043a8bfb2a3d4cbd1c233b9aac1fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00f043a8bfb2a3d4cbd1c233b9aac1fb">&#9670;&nbsp;</a></span>make_opaque()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp; sde::ModuleInput::make_opaque </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags the current input field as opaque. </p>
<p>Input fields are opaque if their value influences memoization. This function will flag the input field as opaque. Since an input field is by default opaque this function is primarily of use when a package wants to ship a module that is based on a copy of another module.</p>
<dl class="section return"><dt>Returns</dt><dd>The current instance flagged as opaque.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a931feb901f2ddfe98025b8c9ddda4783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931feb901f2ddfe98025b8c9ddda4783">&#9670;&nbsp;</a></span>make_optional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp; sde::ModuleInput::make_optional </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags the current input field as optional. </p>
<p>An optional input field does not need to have a value bound to it before the module can run. Calling this function will flag this input field as optional.</p>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instance flagged as optional.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af306efc6cc26213ab0cdec450f18edb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af306efc6cc26213ab0cdec450f18edb3">&#9670;&nbsp;</a></span>make_required()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp; sde::ModuleInput::make_required </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags the current input field as optional. </p>
<p>An optional input field does not need to have a value bound to it before the module can run. Calling this function will flag this input field as required. <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instances default to required so this function is only necessary in very limited circumstances.</p>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instance flagged as optional.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c0ebf269de9d592821b2f3b0136c560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0ebf269de9d592821b2f3b0136c560">&#9670;&nbsp;</a></span>make_transparent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp; sde::ModuleInput::make_transparent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags the current input field as transparent. </p>
<p>Input fields are transparent if their value does not influence memoization. This function will flag the input field as transparent.</p>
<dl class="section return"><dt>Returns</dt><dd>The current instance flagged as transparent.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1309dc0e48981471b9c299167ce0fef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1309dc0e48981471b9c299167ce0fef7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instances are different. </p>
<p>Two <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instances are equivalent if their states are equivalent. This includes the input value they hold, as well as the meta-data such as their descriptions and whether they are transparent. As a disclaimer, there is no feasible way to compare the checks so they are omitted from this comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right side of the operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the instances are equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd2b3600d0a02288fee70ec3ca608163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2b3600d0a02288fee70ec3ca608163">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instances for equality. </p>
<p>Two <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instances are equivalent if their states are equivalent. This includes the input value they hold, as well as the meta-data such as their descriptions and whether they are transparent. As a disclaimer, there is no feasible way to compare the checks so they are omitted from this comparison.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lhs</td><td>The instance on the left side of the operator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance on the right side of the operator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested comparison is true and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a112870c5b5a2fe0cb51a1154f222c55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a112870c5b5a2fe0cb51a1154f222c55e">&#9670;&nbsp;</a></span>ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleInput::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if an input value is ready to be given to a module. </p>
<p>An input is "ready" if it is optional (in which case the user does not need to set it) or if it has a value. Strictly speaking in order for the input to be ready it must:</p>
<ul>
<li>be optional or have a value,</li>
<li>the value must be of the correct type, and</li>
<li>the value must be within the domain of the module</li>
</ul>
<p>However, this class will not let the user (or developer) set the input to a bad value. Consequentially, we are guaranteed that if this input stores a value, that value is within the domain of the module and of the correct type.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the input is ready and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6e0bf4ef13947fc82601e1b1003e57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6e0bf4ef13947fc82601e1b1003e57b">&#9670;&nbsp;</a></span>set_default()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::ModuleInput::set_default </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>new_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Establishes the default value for the input field. </p>
<p>At the moment this function is nothing more than a thin wrapper around <code>change</code> meant to be more descriptive. The intent is to use this function to distinguish between a module developer setting the default value for a module and a user tweaking options to their liking (the latter of which should go through <code>change</code>).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the input to bind.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_value</td><td>The value to bind to the input as the default.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instance with the default value set to <code>new_value</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the type has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::inavalid_argument</td><td>if <code>new_value</code> fails any bounds checks. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ff93c991cdf0a842989a47cc21ee25b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff93c991cdf0a842989a47cc21ee25b">&#9670;&nbsp;</a></span>set_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1ModuleInput.html">ModuleInput</a> &amp; sde::ModuleInput::set_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a>&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the human-readable description of this input field to <code>desc</code>. </p>
<p>Developers of modules are encouraged to associate with each input field a human-readable string, which will then be used as documentation for the input field.</p>
<dl class="section note"><dt>Note</dt><dd>Repeated calls to this function will overwrite the description and not append to it.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>Description of how this input field will be used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instance modified so that it contains <code>desc</code>. The returned value is thus suitable for chaining. </dd></dl>

</div>
</div>
<a id="ac6aae204852da96421a61b320c593126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6aae204852da96421a61b320c593126">&#9670;&nbsp;</a></span>set_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::ModuleInput::set_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the type of this input field to <code>T</code>. </p>
<p>Each input field for a module has a type associated with it. This is the type that the value a user provides must have. This function allows you to set the type of the field associated with this <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> instance. The value can be:</p>
<ul>
<li>can be an unqualified type like <code>int</code> or <code>std::vector&lt;double&gt;</code></li>
<li>a const-reference like <code>const std::vector&lt;double&gt;&amp;</code></li>
</ul>
<p>The value should not be:</p>
<ul>
<li>A pointer (const or otherwise; use a const reference instead)</li>
<li>A non-const reference like <code>std::vector&lt;double&gt;&amp;</code></li>
<li>An rvalue reference like <code>std::vector&lt;double&gt;&amp;&amp;</code><ul>
<li>Just take the parameter by value and leave it up to the user to decide if they want to move the input.</li>
</ul>
</li>
</ul>
<p>To the extent feasible the restrictions on <code>T</code> are enforced at compile-time and will trip static assertions if violated. It is the nature of C++ that you can get around these checks, doing so is undefined behavior.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the field. Must be an rvalue.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current object, with the type set to <code>T</code>, in order to support chaining.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if you attempt to change the type after the value has been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e82c688290e715cd047a4c224f29551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e82c688290e715cd047a4c224f29551">&#9670;&nbsp;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sde::ModuleInput::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bound input as an instance of type <code>T</code>. </p>
<p>This function undoes the type-erasure on the input field. This particular overload allows the user to get the value back by reference assuming you set to bind the input by value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to cast the type-erased input to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value bound to this field as an instance of type <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if no value is bound to this input field. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_any_cast</td><td>if the wrapped value can not be converted to type <code>T</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ae2f9c8f8c5497c44b9ffd452ee7391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ae2f9c8f8c5497c44b9ffd452ee7391">&#9670;&nbsp;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sde::ModuleInput::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bound input as an instance of type <code>T</code>. </p>
<p>This function undoes the type-erasure on the input field. This particular overload allows you to get the value back as either a copy of the bound value or a read-only reference to the the bound value.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to cast the type-erased input to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value bound to this field as an instance of type <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if no value is bound to this input field. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_any_cast</td><td>if the wrapped value can not be converted to type <code>T</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sde/<a class="el" href="module__input_8hpp_source.html">module_input.hpp</a></li>
<li>sde/module_input.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
