<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sde: sde::ModuleBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sde</b></li><li class="navelem"><a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classsde_1_1ModuleBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sde::ModuleBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>API determining how the SDE interacts with a module's implementation.  
 <a href="classsde_1_1ModuleBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="module__base_8hpp_source.html">module_base.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for sde::ModuleBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classsde_1_1ModuleBase.png" usemap="#sde::ModuleBase_map" alt=""/>
  <map id="sde::ModuleBase_map" name="sde::ModuleBase_map">
<area href="classsde_1_1detail___1_1LambdaModule.html" title="Implements a lambda module. " alt="sde::detail_::LambdaModule&lt; PropertyType &gt;" shape="rect" coords="0,56,268,80"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4166be244ea46d459c877f1c4b7fa552"><td class="memItemLeft" align="right" valign="top"><a id="a4166be244ea46d459c877f1c4b7fa552"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a4166be244ea46d459c877f1c4b7fa552">hash_type</a> = std::string</td></tr>
<tr class="memdesc:a4166be244ea46d459c877f1c4b7fa552"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type returned by memoization. <br /></td></tr>
<tr class="separator:a4166be244ea46d459c877f1c4b7fa552"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a78ddc26eafbc055ed44ff3023df6f0de"><td class="memItemLeft" align="right" valign="top"><a id="a78ddc26eafbc055ed44ff3023df6f0de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a78ddc26eafbc055ed44ff3023df6f0de">ModuleBase</a> ()=delete</td></tr>
<tr class="memdesc:a78ddc26eafbc055ed44ff3023df6f0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted to avoid erroneous construction. <br /></td></tr>
<tr class="separator:a78ddc26eafbc055ed44ff3023df6f0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b693d3b1f08070eb87b6c4501346d1"><td class="memItemLeft" align="right" valign="top"><a id="ae7b693d3b1f08070eb87b6c4501346d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#ae7b693d3b1f08070eb87b6c4501346d1">ModuleBase</a> (const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;rhs)=delete</td></tr>
<tr class="memdesc:ae7b693d3b1f08070eb87b6c4501346d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted to avoid erroneous construction. <br /></td></tr>
<tr class="separator:ae7b693d3b1f08070eb87b6c4501346d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af450e2a220d8852857e0fb07c84eff5e"><td class="memItemLeft" align="right" valign="top"><a id="af450e2a220d8852857e0fb07c84eff5e"></a>
<a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#af450e2a220d8852857e0fb07c84eff5e">operator=</a> (const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;rhs)=delete</td></tr>
<tr class="memdesc:af450e2a220d8852857e0fb07c84eff5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted to avoid erroneous assignment. <br /></td></tr>
<tr class="separator:af450e2a220d8852857e0fb07c84eff5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2c30ae092c96945a44a7da41c51cc6"><td class="memItemLeft" align="right" valign="top"><a id="a0d2c30ae092c96945a44a7da41c51cc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a0d2c30ae092c96945a44a7da41c51cc6">ModuleBase</a> (<a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;&amp;rhs)=delete</td></tr>
<tr class="memdesc:a0d2c30ae092c96945a44a7da41c51cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted to avoid erroneous construction. <br /></td></tr>
<tr class="separator:a0d2c30ae092c96945a44a7da41c51cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306f3441290bdaa25668445d8d7f1931"><td class="memItemLeft" align="right" valign="top"><a id="a306f3441290bdaa25668445d8d7f1931"></a>
<a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a306f3441290bdaa25668445d8d7f1931">operator=</a> (<a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;&amp;rhs)=delete</td></tr>
<tr class="memdesc:a306f3441290bdaa25668445d8d7f1931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deleted to avoid erroneous assignment. <br /></td></tr>
<tr class="separator:a306f3441290bdaa25668445d8d7f1931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121dfc97b30af0740485dd05ea82317e"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a121dfc97b30af0740485dd05ea82317e">~ModuleBase</a> ()=default</td></tr>
<tr class="memdesc:a121dfc97b30af0740485dd05ea82317e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard dtor.  <a href="#a121dfc97b30af0740485dd05ea82317e">More...</a><br /></td></tr>
<tr class="separator:a121dfc97b30af0740485dd05ea82317e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3db540534f8d7d0db69ee913afdf32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#abc3db540534f8d7d0db69ee913afdf32">run</a> (<a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> <a class="el" href="classsde_1_1ModuleBase.html#a88f7d5fd1bb64a6f09e9ea8d974203ea">inputs</a>, <a class="el" href="namespacesde_1_1type.html#a347228253f8054a46b3c53da07e7890b">type::submodule_map</a> <a class="el" href="classsde_1_1ModuleBase.html#a4b32d9cb630794cba025a40ca1d19ee5">submods</a>) const</td></tr>
<tr class="memdesc:abc3db540534f8d7d0db69ee913afdf32"><td class="mdescLeft">&#160;</td><td class="mdescRight">SDE-facing API for running the module.  <a href="#abc3db540534f8d7d0db69ee913afdf32">More...</a><br /></td></tr>
<tr class="separator:abc3db540534f8d7d0db69ee913afdf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377f989774ee28899badd85c3b032413"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a377f989774ee28899badd85c3b032413">has_description</a> () const noexcept</td></tr>
<tr class="memdesc:a377f989774ee28899badd85c3b032413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to determine if the module's description has been set.  <a href="#a377f989774ee28899badd85c3b032413">More...</a><br /></td></tr>
<tr class="separator:a377f989774ee28899badd85c3b032413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e1129a83357bce2a7068de49c356f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a64e1129a83357bce2a7068de49c356f1">results</a> () const noexcept</td></tr>
<tr class="memdesc:a64e1129a83357bce2a7068de49c356f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the results this module can compute.  <a href="#a64e1129a83357bce2a7068de49c356f1">More...</a><br /></td></tr>
<tr class="separator:a64e1129a83357bce2a7068de49c356f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88f7d5fd1bb64a6f09e9ea8d974203ea"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a88f7d5fd1bb64a6f09e9ea8d974203ea">inputs</a> () const noexcept</td></tr>
<tr class="memdesc:a88f7d5fd1bb64a6f09e9ea8d974203ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the inputs this module requires.  <a href="#a88f7d5fd1bb64a6f09e9ea8d974203ea">More...</a><br /></td></tr>
<tr class="separator:a88f7d5fd1bb64a6f09e9ea8d974203ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b32d9cb630794cba025a40ca1d19ee5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#a347228253f8054a46b3c53da07e7890b">type::submodule_map</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a4b32d9cb630794cba025a40ca1d19ee5">submods</a> () const noexcept</td></tr>
<tr class="memdesc:a4b32d9cb630794cba025a40ca1d19ee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of submodules requested by the developer.  <a href="#a4b32d9cb630794cba025a40ca1d19ee5">More...</a><br /></td></tr>
<tr class="separator:a4b32d9cb630794cba025a40ca1d19ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121dc6cfe51cec496849c8ef9a554c71"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a121dc6cfe51cec496849c8ef9a554c71">property_types</a> () const noexcept</td></tr>
<tr class="memdesc:a121dc6cfe51cec496849c8ef9a554c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of property types this module satisfies.  <a href="#a121dc6cfe51cec496849c8ef9a554c71">More...</a><br /></td></tr>
<tr class="separator:a121dc6cfe51cec496849c8ef9a554c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3724f1d66e633ea5a12daf76badc178"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesde_1_1type.html#a57864c40693cc764558896980ab0be01">type::rtti</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#ab3724f1d66e633ea5a12daf76badc178">type</a> () const noexcept</td></tr>
<tr class="memdesc:ab3724f1d66e633ea5a12daf76badc178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the RTTI of the derived class.  <a href="#ab3724f1d66e633ea5a12daf76badc178">More...</a><br /></td></tr>
<tr class="separator:ab3724f1d66e633ea5a12daf76badc178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568764e0a19bdef3802e787bfe04faa6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a568764e0a19bdef3802e787bfe04faa6">get_desc</a> () const</td></tr>
<tr class="memdesc:a568764e0a19bdef3802e787bfe04faa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the documentation on what the derived module does.  <a href="#a568764e0a19bdef3802e787bfe04faa6">More...</a><br /></td></tr>
<tr class="separator:a568764e0a19bdef3802e787bfe04faa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8574423826fd12297b22fe1fadb28c"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a6c8574423826fd12297b22fe1fadb28c">citations</a> () const noexcept</td></tr>
<tr class="memdesc:a6c8574423826fd12297b22fe1fadb28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the citations.  <a href="#a6c8574423826fd12297b22fe1fadb28c">More...</a><br /></td></tr>
<tr class="separator:a6c8574423826fd12297b22fe1fadb28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65458182b5ff87efd2bcaf98d6edf766"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a65458182b5ff87efd2bcaf98d6edf766">operator==</a> (const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a65458182b5ff87efd2bcaf98d6edf766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instances for equality.  <a href="#a65458182b5ff87efd2bcaf98d6edf766">More...</a><br /></td></tr>
<tr class="separator:a65458182b5ff87efd2bcaf98d6edf766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71d9ef15b1e89fbb2577f9a697ae478"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#ae71d9ef15b1e89fbb2577f9a697ae478">operator!=</a> (const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ae71d9ef15b1e89fbb2577f9a697ae478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instances are different.  <a href="#ae71d9ef15b1e89fbb2577f9a697ae478">More...</a><br /></td></tr>
<tr class="separator:ae71d9ef15b1e89fbb2577f9a697ae478"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5099ef116dab9af25474be4e730bae9e"><td class="memTemplParams" colspan="2">template&lt;typename DerivedType &gt; </td></tr>
<tr class="memitem:a5099ef116dab9af25474be4e730bae9e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a5099ef116dab9af25474be4e730bae9e">ModuleBase</a> (DerivedType *ptr) noexcept</td></tr>
<tr class="memdesc:a5099ef116dab9af25474be4e730bae9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">the ctor that all modules must call.  <a href="#a5099ef116dab9af25474be4e730bae9e">More...</a><br /></td></tr>
<tr class="separator:a5099ef116dab9af25474be4e730bae9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be116440f2cefc004b25b7939ee6cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a3be116440f2cefc004b25b7939ee6cad">description</a> (<a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> value) noexcept</td></tr>
<tr class="memdesc:a3be116440f2cefc004b25b7939ee6cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the human-readable description of what this module does.  <a href="#a3be116440f2cefc004b25b7939ee6cad">More...</a><br /></td></tr>
<tr class="separator:a3be116440f2cefc004b25b7939ee6cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3954cb5c3d71b77c02a5a09edeab5c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#aa3954cb5c3d71b77c02a5a09edeab5c5">citation</a> (<a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> value)</td></tr>
<tr class="memdesc:aa3954cb5c3d71b77c02a5a09edeab5c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a citation.  <a href="#aa3954cb5c3d71b77c02a5a09edeab5c5">More...</a><br /></td></tr>
<tr class="separator:aa3954cb5c3d71b77c02a5a09edeab5c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17ddaaa61bc47d5b9f331ae20378632"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa17ddaaa61bc47d5b9f331ae20378632"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#aa17ddaaa61bc47d5b9f331ae20378632">add_input</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:aa17ddaaa61bc47d5b9f331ae20378632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an additional input field to this module.  <a href="#aa17ddaaa61bc47d5b9f331ae20378632">More...</a><br /></td></tr>
<tr class="separator:aa17ddaaa61bc47d5b9f331ae20378632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb0c65b8f4d37b1e0c05157618305ae"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#afdb0c65b8f4d37b1e0c05157618305ae">change_input</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:afdb0c65b8f4d37b1e0c05157618305ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a developer to change an input field.  <a href="#afdb0c65b8f4d37b1e0c05157618305ae">More...</a><br /></td></tr>
<tr class="separator:afdb0c65b8f4d37b1e0c05157618305ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7577a7018cd9a99d279358a2a817a30"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7577a7018cd9a99d279358a2a817a30"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#af7577a7018cd9a99d279358a2a817a30">add_result</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:af7577a7018cd9a99d279358a2a817a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an additional result field to this module.  <a href="#af7577a7018cd9a99d279358a2a817a30">More...</a><br /></td></tr>
<tr class="separator:af7577a7018cd9a99d279358a2a817a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d3cbca90b25cfa3c051e117d6d30b9"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#ab9d3cbca90b25cfa3c051e117d6d30b9">change_result</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:ab9d3cbca90b25cfa3c051e117d6d30b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a developer to change a result field.  <a href="#ab9d3cbca90b25cfa3c051e117d6d30b9">More...</a><br /></td></tr>
<tr class="separator:ab9d3cbca90b25cfa3c051e117d6d30b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1e16a1aa5df5fa9538d59e84a8183f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f1e16a1aa5df5fa9538d59e84a8183f"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a2f1e16a1aa5df5fa9538d59e84a8183f">add_submodule</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:a2f1e16a1aa5df5fa9538d59e84a8183f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an additional submodule request to this module.  <a href="#a2f1e16a1aa5df5fa9538d59e84a8183f">More...</a><br /></td></tr>
<tr class="separator:a2f1e16a1aa5df5fa9538d59e84a8183f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8431aec910a66ec0efe9c19d2c239d13"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a8431aec910a66ec0efe9c19d2c239d13">change_submod</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="memdesc:a8431aec910a66ec0efe9c19d2c239d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows a developer to change a submodule request.  <a href="#a8431aec910a66ec0efe9c19d2c239d13">More...</a><br /></td></tr>
<tr class="separator:a8431aec910a66ec0efe9c19d2c239d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0e1fbc23ce34670b8c13d32c4281bb"><td class="memTemplParams" colspan="2">template&lt;typename property_type &gt; </td></tr>
<tr class="memitem:a2c0e1fbc23ce34670b8c13d32c4281bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1ModuleBase.html#a2c0e1fbc23ce34670b8c13d32c4281bb">satisfies_property_type</a> ()</td></tr>
<tr class="memdesc:a2c0e1fbc23ce34670b8c13d32c4281bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies that the derived module satisfies <code>property_type</code>.  <a href="#a2c0e1fbc23ce34670b8c13d32c4281bb">More...</a><br /></td></tr>
<tr class="separator:a2c0e1fbc23ce34670b8c13d32c4281bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>API determining how the SDE interacts with a module's implementation. </p>
<p><a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> implementations derive from the <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> class, which itself is used as a PIMPL for the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class. When users interact with a module they do so with the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class. Hence <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> is the user API and <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> is the developer API.</p>
<p><a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> is meant to be inherited from. In order to avoid the user having to perform polymorphic copies/moves correctly, we simply disable copying/moving <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> objects. In order to portray standard C++ object behavior to the outside world the state of the module is copied into the ModulePIMPL class and copies/moves deal with that state. This also has the advantage of preserving the developer's original settings in the <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> class while allowing the user to set their own defaults in the ModulePIMPL class (although they do it through the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class). The default ctor is deleted to avoid developers erroneously forgetting to set the type (this is done implicitly by passing the this pointer). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a121dfc97b30af0740485dd05ea82317e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121dfc97b30af0740485dd05ea82317e">&#9670;&nbsp;</a></span>~ModuleBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual sde::ModuleBase::~ModuleBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard dtor. </p>
<p>After calling this function all references to the state are invalidated. Of note, however, is that results will only be deleted if the reference count within the enclosing <code>shared_ptr</code> instance goes to zero.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5099ef116dab9af25474be4e730bae9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5099ef116dab9af25474be4e730bae9e">&#9670;&nbsp;</a></span>ModuleBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::ModuleBase::ModuleBase </td>
          <td>(</td>
          <td class="paramtype">DerivedType *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the ctor that all modules must call. </p>
<p>Classes that derive form <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> need to call this constructor to initialize the base. They do this by passing their <code>this</code> pointer to this ctor.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the module deriving from this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>the this pointer of the derived instance</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa17ddaaa61bc47d5b9f331ae20378632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17ddaaa61bc47d5b9f331ae20378632">&#9670;&nbsp;</a></span>add_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::ModuleBase::add_input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an additional input field to this module. </p>
<p>A module automatically has all of the input fields associated with any property types it satisfies. This function can be called to add additional input fields to the module. Any input fields added this way will need to have a default value or be manually set by the user before the module can be run.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">T</td><td>The type of this input field's values.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of the input.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created input so that it can be modified.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the new input field. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7577a7018cd9a99d279358a2a817a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7577a7018cd9a99d279358a2a817a30">&#9670;&nbsp;</a></span>add_result()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::ModuleBase::add_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an additional result field to this module. </p>
<p>A module automatically has all of the result fields associated with any property types it satisfies. This function can be called to add additional result fields to the module. Any result fields added this way will need to be manually requested by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">T</td><td>The type of this result field's value.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of the result.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created result so that it can be modified.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the new result field. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f1e16a1aa5df5fa9538d59e84a8183f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1e16a1aa5df5fa9538d59e84a8183f">&#9670;&nbsp;</a></span>add_submodule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::ModuleBase::add_submodule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an additional submodule request to this module. </p>
<p>A module automatically has all of the submodule requests associated with any property types it satisfies. This function can be called to add additional submodule requests to the module. Any requests added this way will be automatically set to the default module implementation by the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> unless the user or developer binds a value to the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">T</td><td>The property type for the submodule being requested.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of the request.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created request so it can be modified.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the new request. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdb0c65b8f4d37b1e0c05157618305ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb0c65b8f4d37b1e0c05157618305ae">&#9670;&nbsp;</a></span>change_input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; sde::ModuleBase::change_input </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows a developer to change an input field. </p>
<p>A module automatically has all of the input fields associated with any property types it satisfies. Sometimes the descriptions and/or defaults set by those property types are not appropriate. This function returns an existing input field so that the developer can modify it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of the input field you want to modify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested input field</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> is not currently associated with an existing input field name. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9d3cbca90b25cfa3c051e117d6d30b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d3cbca90b25cfa3c051e117d6d30b9">&#9670;&nbsp;</a></span>change_result()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; sde::ModuleBase::change_result </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows a developer to change a result field. </p>
<p>A module automatically has all of the result fields associated with any property types it satisfies. Sometimes the descriptions and/or defaults set by those property types are not appropriate. This function returns an existing result field so that the developer can modify it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of the result field you want to modify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested result field</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> is not currently associated with an existing result field name. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8431aec910a66ec0efe9c19d2c239d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8431aec910a66ec0efe9c19d2c239d13">&#9670;&nbsp;</a></span>change_submod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto&amp; sde::ModuleBase::change_submod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows a developer to change a submodule request. </p>
<p>A module automatically has all of the submodule requests associated with any property types it satisfies. Sometimes the descriptions and/or defaults set by those property types are not appropriate. This function returns an existing submodule request so that the developer can modify it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The name of the submodule request you want to modify.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested submodule request</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if <code>key</code> is not currently associated with an existing submodule request. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3954cb5c3d71b77c02a5a09edeab5c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3954cb5c3d71b77c02a5a09edeab5c5">&#9670;&nbsp;</a></span>citation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::ModuleBase::citation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a citation. </p>
<p><a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> developers should call this function to add a citation to their module. Each call to this function appends a citation onto the internal list.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The new citation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if the internal std::vector has insufficient memory to store the new citation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c8574423826fd12297b22fe1fadb28c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8574423826fd12297b22fe1fadb28c">&#9670;&nbsp;</a></span>citations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto&amp; sde::ModuleBase::citations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the citations. </p>
<p>If the developer has added any literature references for the module those references can be retrieved via this function.</p>
<dl class="section return"><dt>Returns</dt><dd>An std::vector of the citations assoicated with this module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3be116440f2cefc004b25b7939ee6cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be116440f2cefc004b25b7939ee6cad">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::ModuleBase::description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the human-readable description of what this module does. </p>
<p>Developers should call this function in their module's ctor to define what the module does. The value provided to the function will be used for help and documentation purposes and may include reST. Multiple calls to this function will overwrite the description.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The human-readable description of this module</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a568764e0a19bdef3802e787bfe04faa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568764e0a19bdef3802e787bfe04faa6">&#9670;&nbsp;</a></span>get_desc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a>&amp; sde::ModuleBase::get_desc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the documentation on what the derived module does. </p>
<p>Developers are encouraged to set a human-readable documentation string for their modules. If set, that string can be retrieved via this function.</p>
<dl class="section note"><dt>Note</dt><dd>The name of this function is designed to avoid colliding with the setter.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The human-readable documentation of what this module does.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if the description has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a377f989774ee28899badd85c3b032413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377f989774ee28899badd85c3b032413">&#9670;&nbsp;</a></span>has_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleBase::has_description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to determine if the module's description has been set. </p>
<p>Developers are encouraged to provide a human-readable description of what their module does. This string will then be used to generate documentation and help.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the developer has set a description and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88f7d5fd1bb64a6f09e9ea8d974203ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88f7d5fd1bb64a6f09e9ea8d974203ea">&#9670;&nbsp;</a></span>inputs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a>&amp; sde::ModuleBase::inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the inputs this module requires. </p>
<p>This function can be used to retrieve the set of inputs that the developer defined. These are the results as they were defined in the module's ctor and thus are thus always the defaults. Hence using this function to inputs during run_ is a mistake (and will likely fail because some values are not set).</p>
<p>The set of inputs returned by <a class="el" href="classsde_1_1Module.html#a1c5154bc599ed119c31771ee2f13bc2f" title="Returns the inputs this module recognizes. ">Module::inputs</a> is the set of inputs from this function combined with the defaults set by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of inputs that the developer defined.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae71d9ef15b1e89fbb2577f9a697ae478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71d9ef15b1e89fbb2577f9a697ae478">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleBase::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instances are different. </p>
<p>Two <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instances are equivalent if their algorithm is implemented by the same derived class. This is because that class must set the inputs, results, submodules, and property_types the same way every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the instances are equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65458182b5ff87efd2bcaf98d6edf766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65458182b5ff87efd2bcaf98d6edf766">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::ModuleBase::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instances for equality. </p>
<p>Two <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instances are equivalent if their algorithm is implemented by the same derived class. This is because that class must set the inputs, results, submodules, and property_types the same way every time.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the instances are equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a121dc6cfe51cec496849c8ef9a554c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121dc6cfe51cec496849c8ef9a554c71">&#9670;&nbsp;</a></span>property_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto&amp; sde::ModuleBase::property_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of property types this module satisfies. </p>
<p>This function returns the set of property types that the developer okay'd their module to run as. It is used as the seed for the return of the similarly named <a class="el" href="classsde_1_1Module.html#a0c88c7417c8a6e01a08da71bcd5857da" title="Returns the set of property types that this module can be run as. ">Module::property_types</a>, which returns the full set of property_types that the module can be run as. The final list may differ from the list returned by this function if the user explicitly whitelists additional property types.</p>
<dl class="section return"><dt>Returns</dt><dd>The list of property types that this module can be run as.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64e1129a83357bce2a7068de49c356f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e1129a83357bce2a7068de49c356f1">&#9670;&nbsp;</a></span>results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a>&amp; sde::ModuleBase::results </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the results this module can compute. </p>
<p>This function does <b>NOT</b> return actual computed results,, but rather a result_map of the results that can be computed with this module. When you run the module results are returned directly to you, there is no need to call this function unless you want to know ahead of time what results to expect.</p>
<p>This function also serves as a convenient mechanism for developers to construct their module's return value. Namely call this function, copy the result, set the copy's values, return the copy.</p>
<p>It does not make sense for the user to add additional results to a module and the list returned through <a class="el" href="classsde_1_1Module.html#a0dece772a6a9c5b1e2903b9c24445e45" title="Returns the set of results that can be computed by this module. ">Module::results</a> will always be the same as the list returned by this function.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of results that the developer defined this module as being able to compute.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc3db540534f8d7d0db69ee913afdf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3db540534f8d7d0db69ee913afdf32">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a> sde::ModuleBase::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a>&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#a347228253f8054a46b3c53da07e7890b">type::submodule_map</a>&#160;</td>
          <td class="paramname"><em>submods</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SDE-facing API for running the module. </p>
<p>This function is used by the SDE to run the module. Values provided to it have already been validated, and memoization has been attempted. Ultimately all calls to run a module funnel to this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inputs</td><td>The values the module should use as input. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">submods</td><td>The submodules the module should use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whatever quantities the module computes, in a type-erased form.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the module throws. Strong throw guarantee because all inputs are copies. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c0e1fbc23ce34670b8c13d32c4281bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0e1fbc23ce34670b8c13d32c4281bb">&#9670;&nbsp;</a></span>satisfies_property_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename property_type &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::ModuleBase::satisfies_property_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies that the derived module satisfies <code>property_type</code>. </p>
<p>Property types are essentially base classes for modules. This function allows you to specify that your module "derives" from property type <code>property_type</code>. This will cause the SDE to automatically add all inputs and results associated with that property type to the inputs and results of this module. Additionally, this allows your module to be used anywhere a module of property type <code>property_type</code> is needed.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">property_type</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to add the property type's inputs and results. Weak throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b32d9cb630794cba025a40ca1d19ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b32d9cb630794cba025a40ca1d19ee5">&#9670;&nbsp;</a></span>submods()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#a347228253f8054a46b3c53da07e7890b">type::submodule_map</a>&amp; sde::ModuleBase::submods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of submodules requested by the developer. </p>
<p>This function returns the set of submodule requests that were created in the module's ctor. These requests are in the same state they were defined in, which means they are also unlikely to be fulfilled. Hence, using this function to retrieve submodules during your module's run_ member is unlikely to work because you will not get any submodules.</p>
<p>The set of submodules returned by <a class="el" href="classsde_1_1Module.html#abc1aedde11932b2ba7781a17b15080b6" title="Returns the submodule callback points defined by this module. ">Module::submods</a> is the set returned by this function, combined with any defaults set by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of submodules specified by the developer in the ctor.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab3724f1d66e633ea5a12daf76badc178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3724f1d66e633ea5a12daf76badc178">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesde_1_1type.html#a57864c40693cc764558896980ab0be01">type::rtti</a> sde::ModuleBase::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the RTTI of the derived class. </p>
<p>The type of the derived class is used to index caches. More specifically, caches are shared by all module instances of the same C++ type. This function is thus used to associate your module with a cache.</p>
<dl class="section return"><dt>Returns</dt><dd>The RTTI of the derived class.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sde/<a class="el" href="module__base_8hpp_source.html">module_base.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
