<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sde: sde::detail_::ModulePIMPL Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sde</b></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsde_1_1detail___1_1ModulePIMPL-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sde::detail_::ModulePIMPL Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The class that actually contains a module's state.  
 <a href="classsde_1_1detail___1_1ModulePIMPL.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="module__pimpl_8hpp_source.html">module_pimpl.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a31780dd2b7d569bdfab986b606891dcd"><td class="memItemLeft" align="right" valign="top"><a id="a31780dd2b7d569bdfab986b606891dcd"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a31780dd2b7d569bdfab986b606891dcd">base_ptr</a> = std::shared_ptr&lt; const <a class="el" href="classsde_1_1ModuleBase.html">ModuleBase</a> &gt;</td></tr>
<tr class="memdesc:a31780dd2b7d569bdfab986b606891dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used to store the developer-provided implementation. <br /></td></tr>
<tr class="separator:a31780dd2b7d569bdfab986b606891dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4477aedb58a487a30676b7cf4947549d"><td class="memItemLeft" align="right" valign="top"><a id="a4477aedb58a487a30676b7cf4947549d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a4477aedb58a487a30676b7cf4947549d">cache_type</a> = std::map&lt; std::string, <a class="el" href="namespacesde_1_1type.html#af04c106d8030b13d73cc688040037b3f">type::result_map</a> &gt;</td></tr>
<tr class="memdesc:a4477aedb58a487a30676b7cf4947549d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of the object used to store the results computed by the module. <br /></td></tr>
<tr class="separator:a4477aedb58a487a30676b7cf4947549d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c3041e722857ff4371735bb2dbee80"><td class="memItemLeft" align="right" valign="top"><a id="a61c3041e722857ff4371735bb2dbee80"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a61c3041e722857ff4371735bb2dbee80">cache_ptr</a> = std::shared_ptr&lt; <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a4477aedb58a487a30676b7cf4947549d">cache_type</a> &gt;</td></tr>
<tr class="memdesc:a61c3041e722857ff4371735bb2dbee80"><td class="mdescLeft">&#160;</td><td class="mdescRight">How we store the object used for caching. <br /></td></tr>
<tr class="separator:a61c3041e722857ff4371735bb2dbee80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8a8a66c9fbc282bbc379870144532f"><td class="memItemLeft" align="right" valign="top"><a id="a0a8a8a66c9fbc282bbc379870144532f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a0a8a8a66c9fbc282bbc379870144532f">not_set_type</a> = utilities::CaseInsensitiveMap&lt; std::set&lt; <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &gt; &gt;</td></tr>
<tr class="memdesc:a0a8a8a66c9fbc282bbc379870144532f"><td class="mdescLeft">&#160;</td><td class="mdescRight">How we tell you what's preventing your module from running. <br /></td></tr>
<tr class="separator:a0a8a8a66c9fbc282bbc379870144532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06e88553af076db5698a30683726bbf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a06e88553af076db5698a30683726bbf1">ModulePIMPL</a> ()=default</td></tr>
<tr class="memdesc:a06e88553af076db5698a30683726bbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a module with no implementation.  <a href="#a06e88553af076db5698a30683726bbf1">More...</a><br /></td></tr>
<tr class="separator:a06e88553af076db5698a30683726bbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1aecf082056d35b8467357be0051a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#aed1aecf082056d35b8467357be0051a4">ModulePIMPL</a> (const <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;rhs)=default</td></tr>
<tr class="memdesc:aed1aecf082056d35b8467357be0051a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializing this <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> with a deep copy of <code>rhs</code>.  <a href="#aed1aecf082056d35b8467357be0051a4">More...</a><br /></td></tr>
<tr class="separator:aed1aecf082056d35b8467357be0051a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f06882dcd2fdc4bc1727d7a55bec67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#aa5f06882dcd2fdc4bc1727d7a55bec67">operator=</a> (const <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;rhs)=default</td></tr>
<tr class="memdesc:aa5f06882dcd2fdc4bc1727d7a55bec67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a>'s state to a deep copy of <code>rhs</code>.  <a href="#aa5f06882dcd2fdc4bc1727d7a55bec67">More...</a><br /></td></tr>
<tr class="separator:aa5f06882dcd2fdc4bc1727d7a55bec67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b952c8fafbc65127d555a36ce46d650"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a7b952c8fafbc65127d555a36ce46d650">ModulePIMPL</a> (<a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&amp;rhs)=default</td></tr>
<tr class="memdesc:a7b952c8fafbc65127d555a36ce46d650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes this <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> with <code>rhs's</code> state.  <a href="#a7b952c8fafbc65127d555a36ce46d650">More...</a><br /></td></tr>
<tr class="separator:a7b952c8fafbc65127d555a36ce46d650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c9407389ac62b9f995e20150cfc6e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a71c9407389ac62b9f995e20150cfc6e6">operator=</a> (<a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&amp;rhs)=default</td></tr>
<tr class="memdesc:a71c9407389ac62b9f995e20150cfc6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets this <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a>'s state to <code>rhs's</code> state.  <a href="#a71c9407389ac62b9f995e20150cfc6e6">More...</a><br /></td></tr>
<tr class="separator:a71c9407389ac62b9f995e20150cfc6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c104d24ce099ad73bb380670426aac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a80c104d24ce099ad73bb380670426aac">ModulePIMPL</a> (<a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a31780dd2b7d569bdfab986b606891dcd">base_ptr</a> base, <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a61c3041e722857ff4371735bb2dbee80">cache_ptr</a> cache=<a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a61c3041e722857ff4371735bb2dbee80">cache_ptr</a>{})</td></tr>
<tr class="memdesc:a80c104d24ce099ad73bb380670426aac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> that wraps the provided algorithm.  <a href="#a80c104d24ce099ad73bb380670426aac">More...</a><br /></td></tr>
<tr class="separator:a80c104d24ce099ad73bb380670426aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20d2d5be29134ac4684bb8da9167063"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#ab20d2d5be29134ac4684bb8da9167063">~ModulePIMPL</a> ()=default</td></tr>
<tr class="memdesc:ab20d2d5be29134ac4684bb8da9167063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up the state bound to this module.  <a href="#ab20d2d5be29134ac4684bb8da9167063">More...</a><br /></td></tr>
<tr class="separator:ab20d2d5be29134ac4684bb8da9167063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b486affa78691e2a7c1c94e73cdbcb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a8b486affa78691e2a7c1c94e73cdbcb7">has_module</a> () const noexcept</td></tr>
<tr class="memdesc:a8b486affa78691e2a7c1c94e73cdbcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does this module contain an implementation?  <a href="#a8b486affa78691e2a7c1c94e73cdbcb7">More...</a><br /></td></tr>
<tr class="separator:a8b486affa78691e2a7c1c94e73cdbcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015ffc9f65847463de14b2cceb66a236"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a015ffc9f65847463de14b2cceb66a236">has_description</a> () const</td></tr>
<tr class="memdesc:a015ffc9f65847463de14b2cceb66a236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Did the module developer set a description for this module?  <a href="#a015ffc9f65847463de14b2cceb66a236">More...</a><br /></td></tr>
<tr class="separator:a015ffc9f65847463de14b2cceb66a236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f1fb0d30b7374d52cf4822a6faa29f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a28f1fb0d30b7374d52cf4822a6faa29f">locked</a> () const noexcept</td></tr>
<tr class="memdesc:a28f1fb0d30b7374d52cf4822a6faa29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the current module locked?  <a href="#a28f1fb0d30b7374d52cf4822a6faa29f">More...</a><br /></td></tr>
<tr class="separator:a28f1fb0d30b7374d52cf4822a6faa29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6bc88718dc22ee3566a2dd1bd3d7a3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#adb6bc88718dc22ee3566a2dd1bd3d7a3">not_set</a> (const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;in_inputs={}) const</td></tr>
<tr class="memdesc:adb6bc88718dc22ee3566a2dd1bd3d7a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of module state that is not "ready".  <a href="#adb6bc88718dc22ee3566a2dd1bd3d7a3">More...</a><br /></td></tr>
<tr class="separator:adb6bc88718dc22ee3566a2dd1bd3d7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a4c27aba943b9cdce79a3b5406b60a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a51a4c27aba943b9cdce79a3b5406b60a">ready</a> (const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;inps={}) const</td></tr>
<tr class="memdesc:a51a4c27aba943b9cdce79a3b5406b60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if this module is ready to be run.  <a href="#a51a4c27aba943b9cdce79a3b5406b60a">More...</a><br /></td></tr>
<tr class="separator:a51a4c27aba943b9cdce79a3b5406b60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac488b9719a6e6ece43ee155a17b6d908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#ac488b9719a6e6ece43ee155a17b6d908">lock</a> ()</td></tr>
<tr class="memdesc:ac488b9719a6e6ece43ee155a17b6d908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the module and all submodules.  <a href="#ac488b9719a6e6ece43ee155a17b6d908">More...</a><br /></td></tr>
<tr class="separator:ac488b9719a6e6ece43ee155a17b6d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5b74e9ff7e01cf22a012d420b138d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#aa5b74e9ff7e01cf22a012d420b138d16">unlock</a> () noexcept</td></tr>
<tr class="memdesc:aa5b74e9ff7e01cf22a012d420b138d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the module.  <a href="#aa5b74e9ff7e01cf22a012d420b138d16">More...</a><br /></td></tr>
<tr class="separator:aa5b74e9ff7e01cf22a012d420b138d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efabc63a7bc1a3adeded08964236400"><td class="memItemLeft" align="right" valign="top">const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a8efabc63a7bc1a3adeded08964236400">results</a> () const</td></tr>
<tr class="memdesc:a8efabc63a7bc1a3adeded08964236400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of results computed by this module.  <a href="#a8efabc63a7bc1a3adeded08964236400">More...</a><br /></td></tr>
<tr class="separator:a8efabc63a7bc1a3adeded08964236400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a0b98da5e4e78c2ee3b021eb8bbf27"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a97a0b98da5e4e78c2ee3b021eb8bbf27">inputs</a> ()</td></tr>
<tr class="memdesc:a97a0b98da5e4e78c2ee3b021eb8bbf27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inputs bound to this module in a read/write state.  <a href="#a97a0b98da5e4e78c2ee3b021eb8bbf27">More...</a><br /></td></tr>
<tr class="separator:a97a0b98da5e4e78c2ee3b021eb8bbf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae974aee204ba00436f5d9a6465324234"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#ae974aee204ba00436f5d9a6465324234">inputs</a> () const</td></tr>
<tr class="memdesc:ae974aee204ba00436f5d9a6465324234"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inputs bound to this module in a read-only state.  <a href="#ae974aee204ba00436f5d9a6465324234">More...</a><br /></td></tr>
<tr class="separator:ae974aee204ba00436f5d9a6465324234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a6d0ea888864293ed6b16b42c13d36"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#ab0a6d0ea888864293ed6b16b42c13d36">submods</a> ()</td></tr>
<tr class="memdesc:ab0a6d0ea888864293ed6b16b42c13d36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the submodules bound to this module in a read/write state.  <a href="#ab0a6d0ea888864293ed6b16b42c13d36">More...</a><br /></td></tr>
<tr class="separator:ab0a6d0ea888864293ed6b16b42c13d36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1803fa947052498e2d2192db6899b97b"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a1803fa947052498e2d2192db6899b97b">submods</a> () const</td></tr>
<tr class="memdesc:a1803fa947052498e2d2192db6899b97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the submodules bound to this module in a read-only state.  <a href="#a1803fa947052498e2d2192db6899b97b">More...</a><br /></td></tr>
<tr class="separator:a1803fa947052498e2d2192db6899b97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba612072c59345cfd00dd7f117c736db"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#aba612072c59345cfd00dd7f117c736db">property_types</a> ()</td></tr>
<tr class="memdesc:aba612072c59345cfd00dd7f117c736db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of property types that this module can be run as in a read/write state.  <a href="#aba612072c59345cfd00dd7f117c736db">More...</a><br /></td></tr>
<tr class="separator:aba612072c59345cfd00dd7f117c736db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c28274bd3a35ba0a069ce71c2d05cc2"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a9c28274bd3a35ba0a069ce71c2d05cc2">property_types</a> () const</td></tr>
<tr class="memdesc:a9c28274bd3a35ba0a069ce71c2d05cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the set of property types that this module can be run as in a read-only state.  <a href="#a9c28274bd3a35ba0a069ce71c2d05cc2">More...</a><br /></td></tr>
<tr class="separator:a9c28274bd3a35ba0a069ce71c2d05cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2190c12e024495c4172711626ad5dcc4"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a2190c12e024495c4172711626ad5dcc4">description</a> () const</td></tr>
<tr class="memdesc:a2190c12e024495c4172711626ad5dcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the human-readable description provided by the developer.  <a href="#a2190c12e024495c4172711626ad5dcc4">More...</a><br /></td></tr>
<tr class="separator:a2190c12e024495c4172711626ad5dcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8081e13b453902671d19d53bda07909"><td class="memItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#ab8081e13b453902671d19d53bda07909">citations</a> () const</td></tr>
<tr class="memdesc:ab8081e13b453902671d19d53bda07909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of things to cite if you use the module.  <a href="#ab8081e13b453902671d19d53bda07909">More...</a><br /></td></tr>
<tr class="separator:ab8081e13b453902671d19d53bda07909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca379136b8d8c8d3853a8af2d2fa8678"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#aca379136b8d8c8d3853a8af2d2fa8678">hash</a> (<a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;h) const</td></tr>
<tr class="memdesc:aca379136b8d8c8d3853a8af2d2fa8678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash of the current instance using the bound params.  <a href="#aca379136b8d8c8d3853a8af2d2fa8678">More...</a><br /></td></tr>
<tr class="separator:aca379136b8d8c8d3853a8af2d2fa8678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3690a993bca85ae7aab6213b7f1bedf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a3690a993bca85ae7aab6213b7f1bedf5">memoize</a> (<a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;h, <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a97a0b98da5e4e78c2ee3b021eb8bbf27">inputs</a>) const</td></tr>
<tr class="memdesc:a3690a993bca85ae7aab6213b7f1bedf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes a hash for a particular invocation of the <code>run</code> member.  <a href="#a3690a993bca85ae7aab6213b7f1bedf5">More...</a><br /></td></tr>
<tr class="separator:a3690a993bca85ae7aab6213b7f1bedf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41330293dc2cf6282b8a0645c54a06b9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a41330293dc2cf6282b8a0645c54a06b9">profile_info</a> () const</td></tr>
<tr class="memdesc:a41330293dc2cf6282b8a0645c54a06b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns timing data for this module and all submodules.  <a href="#a41330293dc2cf6282b8a0645c54a06b9">More...</a><br /></td></tr>
<tr class="separator:a41330293dc2cf6282b8a0645c54a06b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6388d670a5ca22a37f27437651549b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#aef6388d670a5ca22a37f27437651549b">is_cached</a> (const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;in_inputs)</td></tr>
<tr class="memdesc:aef6388d670a5ca22a37f27437651549b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the result of a call is cached.  <a href="#aef6388d670a5ca22a37f27437651549b">More...</a><br /></td></tr>
<tr class="separator:aef6388d670a5ca22a37f27437651549b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6261a36718638d561d995c588abba670"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a6261a36718638d561d995c588abba670">reset_cache</a> ()</td></tr>
<tr class="memdesc:a6261a36718638d561d995c588abba670"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets cache.  <a href="#a6261a36718638d561d995c588abba670">More...</a><br /></td></tr>
<tr class="separator:a6261a36718638d561d995c588abba670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2cf2c9f5c431d8067b72504f044bff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a9a2cf2c9f5c431d8067b72504f044bff">is_memoizable</a> () const</td></tr>
<tr class="memdesc:a9a2cf2c9f5c431d8067b72504f044bff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the module memoizable?  <a href="#a9a2cf2c9f5c431d8067b72504f044bff">More...</a><br /></td></tr>
<tr class="separator:a9a2cf2c9f5c431d8067b72504f044bff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6860f52627f8d6558d6e49f7694ade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#abc6860f52627f8d6558d6e49f7694ade">turn_off_memoization</a> ()</td></tr>
<tr class="memdesc:abc6860f52627f8d6558d6e49f7694ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off memoization for this module.  <a href="#abc6860f52627f8d6558d6e49f7694ade">More...</a><br /></td></tr>
<tr class="separator:abc6860f52627f8d6558d6e49f7694ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539712ba0174b23f01e619a6fbe36c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a539712ba0174b23f01e619a6fbe36c90">turn_on_memoization</a> ()</td></tr>
<tr class="memdesc:a539712ba0174b23f01e619a6fbe36c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on memoization for this module.  <a href="#a539712ba0174b23f01e619a6fbe36c90">More...</a><br /></td></tr>
<tr class="separator:a539712ba0174b23f01e619a6fbe36c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20fb1f526fd26ebcc7b843a2a2e34e9"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#ac20fb1f526fd26ebcc7b843a2a2e34e9">run</a> (<a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> ps)</td></tr>
<tr class="memdesc:ac20fb1f526fd26ebcc7b843a2a2e34e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually runs the module.  <a href="#ac20fb1f526fd26ebcc7b843a2a2e34e9">More...</a><br /></td></tr>
<tr class="separator:ac20fb1f526fd26ebcc7b843a2a2e34e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a81ffb7c8383a8a809df3db9ecc3f71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a0a81ffb7c8383a8a809df3db9ecc3f71">operator==</a> (const <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a0a81ffb7c8383a8a809df3db9ecc3f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> instances for equality.  <a href="#a0a81ffb7c8383a8a809df3db9ecc3f71">More...</a><br /></td></tr>
<tr class="separator:a0a81ffb7c8383a8a809df3db9ecc3f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589d6a82787819623f0c802fc2a620ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a589d6a82787819623f0c802fc2a620ee">operator!=</a> (const <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a589d6a82787819623f0c802fc2a620ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if two <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> instances are different.  <a href="#a589d6a82787819623f0c802fc2a620ee">More...</a><br /></td></tr>
<tr class="separator:a589d6a82787819623f0c802fc2a620ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The class that actually contains a module's state. </p>
<p>This class contains a module's actual state in the sense that whenever the module is called the values in this class are taken to be the bound values for the inputs, submodules, and property types. Of particular note is it is these values, and not the values in the developer-provided <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instance, that are used. This allows us to preserve the developer's default state while allowing users to override it.</p>
<p>As an implementation note, we choose to punt locked checks to the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class itself. This is because this is best done in templated functions, which would prohibit us from using a PIMPL. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a06e88553af076db5698a30683726bbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e88553af076db5698a30683726bbf1">&#9670;&nbsp;</a></span>ModulePIMPL() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::ModulePIMPL::ModulePIMPL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a module with no implementation. </p>
<p>The <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> instance resulting from this ctor wraps no algorithm, has no description, and is not locked. The only way to make the instance have an algorithm is to assign to it from an instance that already has an algorithm. In general working <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instances will be made by the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> and the only reason to make a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> instance without an algorithm is as a placeholder.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed1aecf082056d35b8467357be0051a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1aecf082056d35b8467357be0051a4">&#9670;&nbsp;</a></span>ModulePIMPL() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::ModulePIMPL::ModulePIMPL </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializing this <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> with a deep copy of <code>rhs</code>. </p>
<p>This ctor will make a deep copy of <code>rhs</code>. The resulting <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> instance will have the same state. Of note this includes locked-ness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to deep copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>rhs</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b952c8fafbc65127d555a36ce46d650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b952c8fafbc65127d555a36ce46d650">&#9670;&nbsp;</a></span>ModulePIMPL() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::ModulePIMPL::ModulePIMPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes this <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> with <code>rhs's</code> state. </p>
<p>This ctor will take ownership of <code>rhs's</code> state. The resulting instance will have the same state, including locked-ness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to take the state of. After this function call <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80c104d24ce099ad73bb380670426aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c104d24ce099ad73bb380670426aac">&#9670;&nbsp;</a></span>ModulePIMPL() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::ModulePIMPL::ModulePIMPL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a31780dd2b7d569bdfab986b606891dcd">base_ptr</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a61c3041e722857ff4371735bb2dbee80">cache_ptr</a>&#160;</td>
          <td class="paramname"><em>cache</em> = <code><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html#a61c3041e722857ff4371735bb2dbee80">cache_ptr</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> that wraps the provided algorithm. </p>
<p>This is the main useful ctor for the <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> class. It take a pointer to a <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instance (which is guaranteed to have a algorithm inside it) and optionally the cache that should be used for memoization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">base</td><td>The ModulBase instance this PIMPL is wrapping. The state (inputs, results, etc.) of the module will stem from this instance. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cache</td><td>The object to use for memoization. Default is a nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy the developer's default state. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab20d2d5be29134ac4684bb8da9167063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20d2d5be29134ac4684bb8da9167063">&#9670;&nbsp;</a></span>~ModulePIMPL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::ModulePIMPL::~ModulePIMPL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees up the state bound to this module. </p>
<p>After this call the cache and results may still persist depending on whether or not their reference counts went to zero upon deletion. Of note the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> usually holds a shared_ptr to the cache and the cache usually holds one to the result.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab8081e13b453902671d19d53bda07909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8081e13b453902671d19d53bda07909">&#9670;&nbsp;</a></span>citations()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::detail_::ModulePIMPL::citations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of things to cite if you use the module. </p>
<p>We intend for most of the modules that are used with the SDE to be developed in an academic context. In those setting it's important to make sure credit is given where credit is due. This function will return a list of literature refrences that should be cited if you use this module.</p>
<dl class="section return"><dt>Returns</dt><dd>A list of citations.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this module does not have an implementation set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2190c12e024495c4172711626ad5dcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2190c12e024495c4172711626ad5dcc4">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::detail_::ModulePIMPL::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the human-readable description provided by the developer. </p>
<p>Developers are encouraged to provide human-readable descriptions of what their modules do. This description will be used as documentation. If the developer set a description then this function can be used to retrieve it.</p>
<dl class="section return"><dt>Returns</dt><dd>The description that the developer set.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this module does not have an implementation. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_optional_access</td><td>if the description was not set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a015ffc9f65847463de14b2cceb66a236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a015ffc9f65847463de14b2cceb66a236">&#9670;&nbsp;</a></span>has_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::ModulePIMPL::has_description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Did the module developer set a description for this module? </p>
<p>This function is used to determine if the developer has set the module's description.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the description has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the current module does not have an implementation. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b486affa78691e2a7c1c94e73cdbcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b486affa78691e2a7c1c94e73cdbcb7">&#9670;&nbsp;</a></span>has_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::ModulePIMPL::has_module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does this module contain an implementation? </p>
<p>The <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> class is responsible for implementing most of this class. The <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> only takes <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instances and therefore always has modules with implementations; however, we allow users to default construct (and copy/move from default constructed instances) which means it is possible for a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> to not have an implementation. This function is used to check whether or not the current module has an implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the module has an implementation and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aca379136b8d8c8d3853a8af2d2fa8678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca379136b8d8c8d3853a8af2d2fa8678">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModulePIMPL::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the hash of the current instance using the bound params. </p>
<p>This function simply calls memoize with the currently bound inputs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The hasher to use for hashing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if any of the hash functions throw. Same throw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a97a0b98da5e4e78c2ee3b021eb8bbf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a0b98da5e4e78c2ee3b021eb8bbf27">&#9670;&nbsp;</a></span>inputs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::detail_::ModulePIMPL::inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inputs bound to this module in a read/write state. </p>
<p>The inputs bound to a module are the union of those specified by the developer and any additional bound values set by the user. This function returns those inputs in a read/write state.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of inputs bound to this module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the implementation of this module has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae974aee204ba00436f5d9a6465324234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae974aee204ba00436f5d9a6465324234">&#9670;&nbsp;</a></span>inputs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::detail_::ModulePIMPL::inputs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the inputs bound to this module in a read-only state. </p>
<p>The inputs bound to a module are the union of those specified by the developer and any additional bound values set by the user. This function returns those inputs in a read-only state.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of inputs bound to this module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the implementation of this module has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef6388d670a5ca22a37f27437651549b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef6388d670a5ca22a37f27437651549b">&#9670;&nbsp;</a></span>is_cached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::ModulePIMPL::is_cached </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;&#160;</td>
          <td class="paramname"><em>in_inputs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether the result of a call is cached. </p>
<p>This function will memoize the provided inputs and determine if the cache holds the result of calling this module. If this object does not have a cache then the result is falsed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_inputs</td><td>The inputs to use in the memoization</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the cache has the value and false otherwise. </dd></dl>

</div>
</div>
<a id="a9a2cf2c9f5c431d8067b72504f044bff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2cf2c9f5c431d8067b72504f044bff">&#9670;&nbsp;</a></span>is_memoizable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::ModulePIMPL::is_memoizable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the module memoizable? </p>
<p>Some modules (lambda_modules or modules that have nondetermenistic results) should not be memoized.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the module is memoizable, false otherwise.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the module doesn't have a cache, results will not be cached even if <code>is_memoizable</code> is true .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the current module does not have an implementation. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac488b9719a6e6ece43ee155a17b6d908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac488b9719a6e6ece43ee155a17b6d908">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModulePIMPL::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Locks the module and all submodules. </p>
<p>A locked module can no longer have its inputs or submodules modified. This function will first lock all submodules (throwing if any of the submodules are not ready to be locked) and then lock the current module. Unlike the calls to the submodules, which know the type that the module will be run as</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std;:runtime_error</td><td>if a submodule is not ready. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28f1fb0d30b7374d52cf4822a6faa29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f1fb0d30b7374d52cf4822a6faa29f">&#9670;&nbsp;</a></span>locked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::ModulePIMPL::locked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the current module locked? </p>
<p>A locked module can not have its state modified. This avoids situations that may invalidate memoization caused by an input changing after the memoization check occurred. This function is used to determine if the current module is locked or not.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the module is locked and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3690a993bca85ae7aab6213b7f1bedf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3690a993bca85ae7aab6213b7f1bedf5">&#9670;&nbsp;</a></span>memoize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModulePIMPL::memoize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a>&#160;</td>
          <td class="paramname"><em>inputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes a hash for a particular invocation of the <code>run</code> member. </p>
<p>For a deterministic module providing the module the same inputs must return the same outputs. We need a way to determine if we have already called the module with a particular set of inputs; that's where this function comes in. This function takes a set of input values, as well as the set of submodules to use, and maps them to a hash value. Barring the universe conspiring against us, that hash value is a concise and unique representation of the input state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The hasher instance to use </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">inputs</td><td>The values of the inputs to hash</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to merge the inputs. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>If the hash function of any input or submodule throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb6bc88718dc22ee3566a2dd1bd3d7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6bc88718dc22ee3566a2dd1bd3d7a3">&#9670;&nbsp;</a></span>not_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sde::detail_::ModulePIMPL::not_set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;&#160;</td>
          <td class="paramname"><em>in_inputs</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a list of module state that is not "ready". </p>
<p>Calling <code>ready</code> is an easy way to determine if the module's <code>run</code> member can be called; however, if the module is not ready it can be a bit of a pain to figure out why. This function will return a map containing the reasons why the module is not ready. The keys of the map describe the part of the module that is not ready. Choices are:</p>
<ul>
<li>"Inputs" to indicate that one or more required inputs have not been set</li>
<li>"Submodules" to indicate that one or more submodules have not been set.</li>
</ul>
<p>For inputs and submodules, the value in the map is the set of input/submodule keys corresponding to the inputs/submodules that are not set yet.</p>
<p>Note that since some inputs will be provided via the property type it is possible for the module to be ready even if all the bound inputs are not. For this reason this function takes an optional list of inputs. These inputs are assumed to be part of the property type's API and will not be included in the value returned by this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">in_inputs</td><td>The set of inputs provided by the property type. Defaults to an empty map. Values are not checked for ready-ness.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A map of this module's state that is not set yet.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the returned object. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the implementation of this module has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a589d6a82787819623f0c802fc2a620ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589d6a82787819623f0c802fc2a620ee">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::ModulePIMPL::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if two <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> instances are different. </p>
<p>Two modules are equivalent if they contain the same algorithm (determined by comparing the <code>base</code> member), they have the same bound inputs, the same bound set of submodules, the same lockedness, and satisfy the same property types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the instances are equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the base comparison throws or if any of the input comparisons throw. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5f06882dcd2fdc4bc1727d7a55bec67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f06882dcd2fdc4bc1727d7a55bec67">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a>&amp; sde::detail_::ModulePIMPL::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a>'s state to a deep copy of <code>rhs</code>. </p>
<p>This function will set the current instance's state to a deep copy of <code>rhs's</code> state. The resulting <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> have the same state as <code>rhs</code> including lockedness. Memory associated with the old state will be freed up and references will thus become invalid. The notable exception is the cache and the results in it, which will only be freed if they are not also in use elsewhere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to deep copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance set to a deep copy of <code>rhs</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy <code>rhs</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71c9407389ac62b9f995e20150cfc6e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c9407389ac62b9f995e20150cfc6e6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a>&amp; sde::detail_::ModulePIMPL::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets this <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a>'s state to <code>rhs's</code> state. </p>
<p>This function will set the current instance's state to <code>rhs's</code> state. The resulting <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> have the same state as <code>rhs</code> including lockedness. Memory associated with the old state will be freed up and references will thus become invalid. The notable exception is the cache and the results in it, which will only be freed if they are not also in use elsewhere.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to take the state of. After this operation <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance, now with <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a81ffb7c8383a8a809df3db9ecc3f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a81ffb7c8383a8a809df3db9ecc3f71">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::ModulePIMPL::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html">ModulePIMPL</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsde_1_1detail___1_1ModulePIMPL.html" title="The class that actually contains a module&#39;s state. ">ModulePIMPL</a> instances for equality. </p>
<p>Two modules are equivalent if they contain the same algorithm (determined by comparing the <code>base</code> member), they have the same bound inputs, the same bound set of submodules, the same lockedness, and satisfy the same property types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the instances are equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the base comparison throws or if any of the input comparisons throw. Same guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41330293dc2cf6282b8a0645c54a06b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41330293dc2cf6282b8a0645c54a06b9">&#9670;&nbsp;</a></span>profile_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sde::detail_::ModulePIMPL::profile_info </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns timing data for this module and all submodules. </p>
<p>Each time the run member is called the time for the call (including all SDE overhead) is recorded. This also occurs for all calls to submodules' run members. This function creates a formatted string with this module's timing data, including the breakdown in terms of submodule calls.</p>
<dl class="section return"><dt>Returns</dt><dd>All timing data collected for this module and its submodules as a formatted string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there's insufficient memory to allocate the return. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba612072c59345cfd00dd7f117c736db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba612072c59345cfd00dd7f117c736db">&#9670;&nbsp;</a></span>property_types() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::detail_::ModulePIMPL::property_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of property types that this module can be run as in a read/write state. </p>
<p>The SDE will not implicitly convert a module. This function returns the list of property types that the SDE is allowed to convert the module to. The final list is the union of the property types whitelisted by the developer and those whitelisted by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of property types that this module satisfies.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this PIMPL does not have an implementation. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c28274bd3a35ba0a069ce71c2d05cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c28274bd3a35ba0a069ce71c2d05cc2">&#9670;&nbsp;</a></span>property_types() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::detail_::ModulePIMPL::property_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of property types that this module can be run as in a read-only state. </p>
<p>The SDE will not implicitly convert a module. This function returns the list of property types that the SDE is allowed to convert the module to. The final list is the union of the property types whitelisted by the developer and those whitelisted by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of property types that this module satisfies.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if this PIMPL does not have an implementation. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51a4c27aba943b9cdce79a3b5406b60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a4c27aba943b9cdce79a3b5406b60a">&#9670;&nbsp;</a></span>ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::ModulePIMPL::ready </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a> &amp;&#160;</td>
          <td class="paramname"><em>inps</em> = <code>{}</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if this module is ready to be run. </p>
<p>This function wraps <code>not_set</code> and simply asserts that no problems come back.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">inps</td><td>The inputs to forward to <code>not_set</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the module is ready and false otherwise</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if an implementation has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_alloc</td><td>if <code>not_set</code> has insufficient memory. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6261a36718638d561d995c588abba670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6261a36718638d561d995c588abba670">&#9670;&nbsp;</a></span>reset_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModulePIMPL::reset_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets cache. </p>
<p>This function will reset cache.</p>
<dl class="section warning"><dt>Warning</dt><dd>This will result in losing all the data (for all instances of this module) stored in the cache. </dd></dl>

</div>
</div>
<a id="a8efabc63a7bc1a3adeded08964236400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efabc63a7bc1a3adeded08964236400">&#9670;&nbsp;</a></span>results()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const auto &amp; sde::detail_::ModulePIMPL::results </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the set of results computed by this module. </p>
<p>A module's results are the union of the results of each property type it satisfies as well as any additional results the developer specified. This set can not change once the developer has established it since adding an additional result requires modifying the algorithm to return an additional result. This is why we do not allow the user to modify the result fields. This function will return the set of results that a module can compute. The resulting set will not contain any results, but simply serves as a list of what will be computed.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of results that this module can compute.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if no implementation has been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac20fb1f526fd26ebcc7b843a2a2e34e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20fb1f526fd26ebcc7b843a2a2e34e9">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sde::detail_::ModulePIMPL::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aead20624a5267fc6d91e3b5fd1a777f0">type::input_map</a>&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Actually runs the module. </p>
<p>This is the function with all of the SDE magic. Ultimately it will call the run function of the wrapped <a class="el" href="classsde_1_1ModuleBase.html" title="API determining how the SDE interacts with a module&#39;s implementation. ">ModuleBase</a> instance, but before it does that it ensures the module is ready to run, locks it, and checks the cache for the result. If the result is not found in the cache it finally calls the wrapped instance. After the call the result will be cached and returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ps</td><td>The input parameters set by the user.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whatever the module returns.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the module does not have an implementation, the provided inputs are not ready, or if the module is not ready. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>If the module throws. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0a6d0ea888864293ed6b16b42c13d36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a6d0ea888864293ed6b16b42c13d36">&#9670;&nbsp;</a></span>submods() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::detail_::ModulePIMPL::submods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the submodules bound to this module in a read/write state. </p>
<p>The submodules bound to a module are the union of those specified by the developer and any additional bound values set by the user. This function returns those submodule requests in a read/write state.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of submodule requests bound to this module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the implementation of this module has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1803fa947052498e2d2192db6899b97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1803fa947052498e2d2192db6899b97b">&#9670;&nbsp;</a></span>submods() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::detail_::ModulePIMPL::submods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the submodules bound to this module in a read-only state. </p>
<p>The submodules bound to a module are the union of those specified by the developer and any additional bound values set by the user. This function returns those submodule requests in a read-only state.</p>
<dl class="section return"><dt>Returns</dt><dd>The set of submodule requests bound to this module.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the implementation of this module has not been set. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc6860f52627f8d6558d6e49f7694ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6860f52627f8d6558d6e49f7694ade">&#9670;&nbsp;</a></span>turn_off_memoization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModulePIMPL::turn_off_memoization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns off memoization for this module. </p>
<p>This function will disable memoization for this module. Note that memoization is on for all modules except lambda_modules by default.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the current module does not have an implementation. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a539712ba0174b23f01e619a6fbe36c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539712ba0174b23f01e619a6fbe36c90">&#9670;&nbsp;</a></span>turn_on_memoization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModulePIMPL::turn_on_memoization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Turns on memoization for this module. </p>
<dl class="section warning"><dt>Warning</dt><dd>If the module doesn't have a cache, results will not be cached even if this function is called and <code>is_memoizable</code> is true .</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the current module does not have an implementation. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5b74e9ff7e01cf22a012d420b138d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5b74e9ff7e01cf22a012d420b138d16">&#9670;&nbsp;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::ModulePIMPL::unlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unlocks the module. </p>
<p>This will not unlock the submodules because we can not do that safely. This function is only used internally within the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class. Users are not allowed to unlock modules.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sde/detail_/<a class="el" href="module__pimpl_8hpp_source.html">module_pimpl.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
