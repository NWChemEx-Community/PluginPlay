<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sde: sde::SubmoduleRequest Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sde</b></li><li class="navelem"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classsde_1_1SubmoduleRequest-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sde::SubmoduleRequest Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that wraps a module's request for a particular submodule.  
 <a href="classsde_1_1SubmoduleRequest.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="submodule__request_8hpp_source.html">submodule_request.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ee1a9759d0a04e4e7e5958b3dfefe52"><td class="memItemLeft" align="right" valign="top"><a id="a5ee1a9759d0a04e4e7e5958b3dfefe52"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a5ee1a9759d0a04e4e7e5958b3dfefe52">module_ptr</a> = std::shared_ptr&lt; <a class="el" href="classsde_1_1Module.html">Module</a> &gt;</td></tr>
<tr class="memdesc:a5ee1a9759d0a04e4e7e5958b3dfefe52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of a shared pointer to a module, how the submodule is stored. <br /></td></tr>
<tr class="separator:a5ee1a9759d0a04e4e7e5958b3dfefe52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9bc00dac445d64e7d97950428f7ef8bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a9bc00dac445d64e7d97950428f7ef8bb">SubmoduleRequest</a> ()</td></tr>
<tr class="memdesc:a9bc00dac445d64e7d97950428f7ef8bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty request.  <a href="#a9bc00dac445d64e7d97950428f7ef8bb">More...</a><br /></td></tr>
<tr class="separator:a9bc00dac445d64e7d97950428f7ef8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd3475d550c3b35fd621539c2fbca4b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a9dd3475d550c3b35fd621539c2fbca4b">SubmoduleRequest</a> (const <a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;rhs)</td></tr>
<tr class="memdesc:a9dd3475d550c3b35fd621539c2fbca4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current request's state to a deep copy of <code>rhs</code>.  <a href="#a9dd3475d550c3b35fd621539c2fbca4b">More...</a><br /></td></tr>
<tr class="separator:a9dd3475d550c3b35fd621539c2fbca4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5a610f24d275efb7cdd484537f2d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a8f5a610f24d275efb7cdd484537f2d4e">operator=</a> (const <a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8f5a610f24d275efb7cdd484537f2d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current request's state to a deep copy of <code>rhs</code>.  <a href="#a8f5a610f24d275efb7cdd484537f2d4e">More...</a><br /></td></tr>
<tr class="separator:a8f5a610f24d275efb7cdd484537f2d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b738b8a462df9b4c7682f8a066450ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a2b738b8a462df9b4c7682f8a066450ab">SubmoduleRequest</a> (<a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a2b738b8a462df9b4c7682f8a066450ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of another instance's state.  <a href="#a2b738b8a462df9b4c7682f8a066450ab">More...</a><br /></td></tr>
<tr class="separator:a2b738b8a462df9b4c7682f8a066450ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74313b3e225c12f2e7c9c2d4d6018012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a74313b3e225c12f2e7c9c2d4d6018012">operator=</a> (<a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="memdesc:a74313b3e225c12f2e7c9c2d4d6018012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes ownership of another instance's state.  <a href="#a74313b3e225c12f2e7c9c2d4d6018012">More...</a><br /></td></tr>
<tr class="separator:a74313b3e225c12f2e7c9c2d4d6018012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c25e914ac659c8d0ac959c3829b996"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a54c25e914ac659c8d0ac959c3829b996">~SubmoduleRequest</a> () noexcept</td></tr>
<tr class="memdesc:a54c25e914ac659c8d0ac959c3829b996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard destructor.  <a href="#a54c25e914ac659c8d0ac959c3829b996">More...</a><br /></td></tr>
<tr class="separator:a54c25e914ac659c8d0ac959c3829b996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116e4add573cefd9b8722e71c536dac8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a116e4add573cefd9b8722e71c536dac8">has_type</a> () const noexcept</td></tr>
<tr class="memdesc:a116e4add573cefd9b8722e71c536dac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the property type the submodule needs to satisfy been set?  <a href="#a116e4add573cefd9b8722e71c536dac8">More...</a><br /></td></tr>
<tr class="separator:a116e4add573cefd9b8722e71c536dac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bc54f8497898c676eabe5d12670fe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a14bc54f8497898c676eabe5d12670fe9">has_module</a> () const noexcept</td></tr>
<tr class="memdesc:a14bc54f8497898c676eabe5d12670fe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has this request been fulfilled?  <a href="#a14bc54f8497898c676eabe5d12670fe9">More...</a><br /></td></tr>
<tr class="separator:a14bc54f8497898c676eabe5d12670fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8893d05c6e7f72946b48d59f561c3ee3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a8893d05c6e7f72946b48d59f561c3ee3">has_description</a> () const noexcept</td></tr>
<tr class="memdesc:a8893d05c6e7f72946b48d59f561c3ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Has the description been set?  <a href="#a8893d05c6e7f72946b48d59f561c3ee3">More...</a><br /></td></tr>
<tr class="separator:a8893d05c6e7f72946b48d59f561c3ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f1a3f0222d94245843f09c03bf3712"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#af5f1a3f0222d94245843f09c03bf3712">ready</a> () const noexcept</td></tr>
<tr class="memdesc:af5f1a3f0222d94245843f09c03bf3712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the wrapped submodule can be used.  <a href="#af5f1a3f0222d94245843f09c03bf3712">More...</a><br /></td></tr>
<tr class="separator:af5f1a3f0222d94245843f09c03bf3712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925bb55fadc74ff6ebccfc1f2c4071d1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a925bb55fadc74ff6ebccfc1f2c4071d1"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a925bb55fadc74ff6ebccfc1f2c4071d1">set_type</a> ()</td></tr>
<tr class="memdesc:a925bb55fadc74ff6ebccfc1f2c4071d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the property type the submodule must satisfy.  <a href="#a925bb55fadc74ff6ebccfc1f2c4071d1">More...</a><br /></td></tr>
<tr class="separator:a925bb55fadc74ff6ebccfc1f2c4071d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc8967b43de1a364e337d0905df1633"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a9dc8967b43de1a364e337d0905df1633">change</a> (<a class="el" href="classsde_1_1SubmoduleRequest.html#a5ee1a9759d0a04e4e7e5958b3dfefe52">module_ptr</a> new_module)</td></tr>
<tr class="memdesc:a9dc8967b43de1a364e337d0905df1633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the module that is to be used to satisfy the request.  <a href="#a9dc8967b43de1a364e337d0905df1633">More...</a><br /></td></tr>
<tr class="separator:a9dc8967b43de1a364e337d0905df1633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafbd05e02d2a0263373de6f69a3b499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#aeafbd05e02d2a0263373de6f69a3b499">set_description</a> (<a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> desc) noexcept</td></tr>
<tr class="memdesc:aeafbd05e02d2a0263373de6f69a3b499"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the human-readable description for the this request.  <a href="#aeafbd05e02d2a0263373de6f69a3b499">More...</a><br /></td></tr>
<tr class="separator:aeafbd05e02d2a0263373de6f69a3b499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae054bea1fe7b6f6a940a41e719e2f673"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesde_1_1type.html#a57864c40693cc764558896980ab0be01">type::rtti</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#ae054bea1fe7b6f6a940a41e719e2f673">type</a> () const</td></tr>
<tr class="memdesc:ae054bea1fe7b6f6a940a41e719e2f673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the RTTI of the property type this submodule must satisfy.  <a href="#ae054bea1fe7b6f6a940a41e719e2f673">More...</a><br /></td></tr>
<tr class="separator:ae054bea1fe7b6f6a940a41e719e2f673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0590b298ed08b614dba97055df5eaf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classsde_1_1Module.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a3f0590b298ed08b614dba97055df5eaf">value</a> () const</td></tr>
<tr class="memdesc:a3f0590b298ed08b614dba97055df5eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the module used to satisfy this request in a read-only state.  <a href="#a3f0590b298ed08b614dba97055df5eaf">More...</a><br /></td></tr>
<tr class="separator:a3f0590b298ed08b614dba97055df5eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cca9515545d9be63c349f6aa79319ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1Module.html">Module</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a2cca9515545d9be63c349f6aa79319ab">value</a> ()</td></tr>
<tr class="memdesc:a2cca9515545d9be63c349f6aa79319ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the module used to satisfy this request in a read/write state.  <a href="#a2cca9515545d9be63c349f6aa79319ab">More...</a><br /></td></tr>
<tr class="separator:a2cca9515545d9be63c349f6aa79319ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b19e82a414c2e145385cf38250663d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a76b19e82a414c2e145385cf38250663d">description</a> () const</td></tr>
<tr class="memdesc:a76b19e82a414c2e145385cf38250663d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to retrieve the description of this request.  <a href="#a76b19e82a414c2e145385cf38250663d">More...</a><br /></td></tr>
<tr class="separator:a76b19e82a414c2e145385cf38250663d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9ba6421721a7342fecd9859fdaabf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a9a9ba6421721a7342fecd9859fdaabf2">lock</a> ()</td></tr>
<tr class="memdesc:a9a9ba6421721a7342fecd9859fdaabf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks the submodule.  <a href="#a9a9ba6421721a7342fecd9859fdaabf2">More...</a><br /></td></tr>
<tr class="separator:a9a9ba6421721a7342fecd9859fdaabf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229f92e8e4a3439ead041de79396cf20"><td class="memTemplParams" colspan="2">template&lt;typename property_type , typename... Args&gt; </td></tr>
<tr class="memitem:a229f92e8e4a3439ead041de79396cf20"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a229f92e8e4a3439ead041de79396cf20">run_as</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a229f92e8e4a3439ead041de79396cf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the submodule with the given arguments.  <a href="#a229f92e8e4a3439ead041de79396cf20">More...</a><br /></td></tr>
<tr class="separator:a229f92e8e4a3439ead041de79396cf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7a1582ed9cd97b1deb138b1b02fa5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#aae7a1582ed9cd97b1deb138b1b02fa5d">hash</a> (<a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;h) const</td></tr>
<tr class="memdesc:aae7a1582ed9cd97b1deb138b1b02fa5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashes the module wrapped in the class.  <a href="#aae7a1582ed9cd97b1deb138b1b02fa5d">More...</a><br /></td></tr>
<tr class="separator:aae7a1582ed9cd97b1deb138b1b02fa5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6463d7a56aa77da4b5c2a0c34ab865d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a6463d7a56aa77da4b5c2a0c34ab865d7">operator==</a> (const <a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a6463d7a56aa77da4b5c2a0c34ab865d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> instances for equality.  <a href="#a6463d7a56aa77da4b5c2a0c34ab865d7">More...</a><br /></td></tr>
<tr class="separator:a6463d7a56aa77da4b5c2a0c34ab865d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45cb96c4f4b6012a0e89e3f69e158422"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1SubmoduleRequest.html#a45cb96c4f4b6012a0e89e3f69e158422">operator!=</a> (const <a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a45cb96c4f4b6012a0e89e3f69e158422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dertermines if two <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> instances are different.  <a href="#a45cb96c4f4b6012a0e89e3f69e158422">More...</a><br /></td></tr>
<tr class="separator:a45cb96c4f4b6012a0e89e3f69e158422"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class that wraps a module's request for a particular submodule. </p>
<p>When a module needs to use a submodule as part of its <code>run</code> function, the module creates an instance of this class. For the most part, a submodule request comes down to one thing, the property type that the submodule must satisfy. The <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> class stores the requested property type as well as some other metadata such as the description.</p>
<p>Note that there is a cyclic dependency between the <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> class and the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class, which results from the fact that a <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> holds a list of submodule requests and that each submodule request holds the module that is being used to satisfy the request. In practice this dependency is trivially handled because both classes only need forward declarations of the other for their respective declarations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9bc00dac445d64e7d97950428f7ef8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc00dac445d64e7d97950428f7ef8bb">&#9670;&nbsp;</a></span>SubmoduleRequest() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sde::SubmoduleRequest::SubmoduleRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes an empty request. </p>
<p>The request resulting from this call will have no description, no type, and no module.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to allocate the PIMPL. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9dd3475d550c3b35fd621539c2fbca4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd3475d550c3b35fd621539c2fbca4b">&#9670;&nbsp;</a></span>SubmoduleRequest() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">sde::SubmoduleRequest::SubmoduleRequest </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the current request's state to a deep copy of <code>rhs</code>. </p>
<p>This funciton will make a deep copy of another <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a>'s state. This includes any bound module, if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance's state to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory for the copy. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b738b8a462df9b4c7682f8a066450ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b738b8a462df9b4c7682f8a066450ab">&#9670;&nbsp;</a></span>SubmoduleRequest() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::SubmoduleRequest::SubmoduleRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of another instance's state. </p>
<p>This ctor will make the current instance own <code>rhs's</code> state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state will be taken. After this operation <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54c25e914ac659c8d0ac959c3829b996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c25e914ac659c8d0ac959c3829b996">&#9670;&nbsp;</a></span>~SubmoduleRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::SubmoduleRequest::~SubmoduleRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard destructor. </p>
<p>After calling the dtor all references to metadata are invalid and the reference count of the wrapped module is decreased by one. Hence references to the module remain valid after the call to the dtor, until the reference count goes to zero.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9dc8967b43de1a364e337d0905df1633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc8967b43de1a364e337d0905df1633">&#9670;&nbsp;</a></span>change()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sde::SubmoduleRequest::change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1SubmoduleRequest.html#a5ee1a9759d0a04e4e7e5958b3dfefe52">module_ptr</a>&#160;</td>
          <td class="paramname"><em>new_module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the module that is to be used to satisfy the request. </p>
<p>This function is designed to be called by the <a class="el" href="classsde_1_1ModuleManager.html" title="Class responsible for manipulating. ">ModuleManager</a> via the <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> class in order to fulfill the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>Pointer to the module to use.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if <code>ptr</code> is null. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::bad_optional_access</td><td>if the property type has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if <code>ptr</code> is not of the correct property type. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a76b19e82a414c2e145385cf38250663d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b19e82a414c2e145385cf38250663d">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a> &amp; sde::SubmoduleRequest::description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to retrieve the description of this request. </p>
<p>Developers are encouraged to set the description of how a submodule will be used. If they set this description it can be retrieved via this function.</p>
<dl class="section return"><dt>Returns</dt><dd>The human-readable description of how this submodule will be used</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if the description has not been set yet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8893d05c6e7f72946b48d59f561c3ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8893d05c6e7f72946b48d59f561c3ee3">&#9670;&nbsp;</a></span>has_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::SubmoduleRequest::has_description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the description been set? </p>
<p>Developers are encouraged to explain how a submodule will be used. This prose is the description of the <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> and is used for documentation and help purposes only. This function checks if the description has been set.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the description has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14bc54f8497898c676eabe5d12670fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bc54f8497898c676eabe5d12670fe9">&#9670;&nbsp;</a></span>has_module()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::SubmoduleRequest::has_module </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has this request been fulfilled? </p>
<p>This function checks to see if a submodule has been assigned to this request. Use set_module to actually fulfill the request.</p>
<dl class="section return"><dt>Returns</dt><dd>True if this request is satisfied and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a116e4add573cefd9b8722e71c536dac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116e4add573cefd9b8722e71c536dac8">&#9670;&nbsp;</a></span>has_type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::SubmoduleRequest::has_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Has the property type the submodule needs to satisfy been set? </p>
<p>This request is for a submodule that will compute a property for the parent module. This function is used to determine if the property type that the submodule must satisfy has been set.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the property type has been set and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae7a1582ed9cd97b1deb138b1b02fa5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7a1582ed9cd97b1deb138b1b02fa5d">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sde::SubmoduleRequest::hash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#afd8e61a56663827b694b7aa1f1628d62">type::hasher</a> &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hashes the module wrapped in the class. </p>
<p>If this request contains a module, this function will hash it. If it does not contain a module, <code>h</code> will not be modified..</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>The hasher instance to use. The state of the hasher will be updated with a hash of the wrapped module.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the hash function of the module throws. Same guarantee as the module's hash function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a9ba6421721a7342fecd9859fdaabf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9ba6421721a7342fecd9859fdaabf2">&#9670;&nbsp;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sde::SubmoduleRequest::lock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks the submodule. </p>
<p>A locked module can no longer have its inputs and submodules modified. Locking a module helps avoid data races and problems with memoization that can occur if the inputs/submodules changed. This function locks the submodule. Since it would not be possible to ready a locked submodule (recall the property type is known and set) this function will throw if one attempts to lock an unready module.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the submodule is not ready. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a45cb96c4f4b6012a0e89e3f69e158422"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45cb96c4f4b6012a0e89e3f69e158422">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::SubmoduleRequest::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dertermines if two <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> instances are different. </p>
<p>Two <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> instances are equivalent if they both:</p><ul>
<li>request the same property type,</li>
<li>have the same description, and</li>
<li>are not satisfied or are both satisfied with the same module</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The request to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the this instances are the same and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the comparison between the two modules throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f5a610f24d275efb7cdd484537f2d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5a610f24d275efb7cdd484537f2d4e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp; sde::SubmoduleRequest::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current request's state to a deep copy of <code>rhs</code>. </p>
<p>This function will overwrite the current instance's state with a deep copy of another <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a>'s state. This includes any bound module, if it exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance's state to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance containing a deep copy of <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory for the copy. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74313b3e225c12f2e7c9c2d4d6018012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74313b3e225c12f2e7c9c2d4d6018012">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp; sde::SubmoduleRequest::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes ownership of another instance's state. </p>
<p>This function will overwrite the current instance's state with <code>rhs's</code> state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance whose state will be taken. After this operation <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance with <code>rhs's</code> state.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6463d7a56aa77da4b5c2a0c34ab865d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6463d7a56aa77da4b5c2a0c34ab865d7">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::SubmoduleRequest::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> instances for equality. </p>
<p>Two <a class="el" href="classsde_1_1SubmoduleRequest.html" title="Class that wraps a module&#39;s request for a particular submodule. ">SubmoduleRequest</a> instances are equivalent if they both:</p><ul>
<li>request the same property type,</li>
<li>have the same description, and</li>
<li>are not satisfied or are both satisfied with the same module</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The request to compare against</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the this instance is the same as <code>rhs</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If the comparison between the two modules throws. Same throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5f1a3f0222d94245843f09c03bf3712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f1a3f0222d94245843f09c03bf3712">&#9670;&nbsp;</a></span>ready()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::SubmoduleRequest::ready </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the wrapped submodule can be used. </p>
<p>A submodule can be used if there is actually a submodule wrapped in the request and if that submodule reports that it is ready for use (the criteria for it being ready for use are identical to the <a class="el" href="classsde_1_1Module.html" title="The public API of all modules. ">Module</a> class).</p>
<dl class="section return"><dt>Returns</dt><dd>True if the current request contains a submodule that is ready for use and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a229f92e8e4a3439ead041de79396cf20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229f92e8e4a3439ead041de79396cf20">&#9670;&nbsp;</a></span>run_as()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename property_type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto sde::SubmoduleRequest::run_as </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the submodule with the given arguments. </p>
<p>This function is a convenience function for running the wrapped submodule as a particular property type. It is semantically the same as calling:</p>
<div class="fragment"><div class="line">this-&gt;<a class="code" href="classsde_1_1SubmoduleRequest.html#a3f0590b298ed08b614dba97055df5eaf">value</a>().<a class="code" href="classsde_1_1Module.html#afffa0771774b59785bf8270679ef27a4">run_as</a>&lt;T&gt;(args...);</div></div><!-- fragment --><p>aside from the fact that it also asserts that the submodule is being run as the correct property type. Expert users can access the wrapped module via the <code>value</code> member and perform more advanced runs that way.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">property_type</td><td>The class defining the property type that the submodule should be run as. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the arguments to the property type</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The values for the arguments to forward to the submodule.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whatever the property type returns</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if the type has not been set yet. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the submodule is being run as a property type other than the one it should be. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the submodule has not been set yet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeafbd05e02d2a0263373de6f69a3b499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafbd05e02d2a0263373de6f69a3b499">&#9670;&nbsp;</a></span>set_description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1SubmoduleRequest.html">SubmoduleRequest</a> &amp; sde::SubmoduleRequest::set_description </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#a53b2dce347ea3b9f5c70671f8320fe21">type::description</a>&#160;</td>
          <td class="paramname"><em>desc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the human-readable description for the this request. </p>
<p>Developers are encouraged to provide descriptions for how a submodule will be used. This description is set by calling this function. If the request contains a description prior to this call it will be overwritten by this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">desc</td><td>The new value for this request's description.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance with the description set to <code>desc</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a925bb55fadc74ff6ebccfc1f2c4071d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925bb55fadc74ff6ebccfc1f2c4071d1">&#9670;&nbsp;</a></span>set_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto &amp; sde::SubmoduleRequest::set_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the property type the submodule must satisfy. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance with the required property type set to <code>T</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the module has already been set and the requested property type is inconsistent with the module. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae054bea1fe7b6f6a940a41e719e2f673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae054bea1fe7b6f6a940a41e719e2f673">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesde_1_1type.html#a57864c40693cc764558896980ab0be01">type::rtti</a> sde::SubmoduleRequest::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the RTTI of the property type this submodule must satisfy. </p>
<p>The developer must specify the property type that the submodule satisfies using set_type. This function is the accessor providing access to the type that the developer specified.</p>
<dl class="section return"><dt>Returns</dt><dd>The RTTI of the property type that the submodule must satisfy.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_optional_access</td><td>if <a class="el" href="classsde_1_1SubmoduleRequest.html#a116e4add573cefd9b8722e71c536dac8" title="Has the property type the submodule needs to satisfy been set? ">has_type()</a> is false. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f0590b298ed08b614dba97055df5eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0590b298ed08b614dba97055df5eaf">&#9670;&nbsp;</a></span>value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classsde_1_1Module.html">Module</a> &amp; sde::SubmoduleRequest::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the module used to satisfy this request in a read-only state. </p>
<p>This function allows one to retrieve the module used to satisfy the request in a read-only state. This is useful for inspection and running the module.</p>
<dl class="section return"><dt>Returns</dt><dd>The module satisfying this request.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the request has not been fulfilled yet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2cca9515545d9be63c349f6aa79319ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cca9515545d9be63c349f6aa79319ab">&#9670;&nbsp;</a></span>value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1Module.html">Module</a> &amp; sde::SubmoduleRequest::value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides the module used to satisfy this request in a read/write state. </p>
<p>This function allows one to retrieve the module used to satisfy the request in a read/write state. This is useful for changing inputs before running the module.</p>
<dl class="section return"><dt>Returns</dt><dd>The module satisfying this request.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the request has not been fulfilled yet. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sde/<a class="el" href="submodule__request_8hpp_source.html">submodule_request.hpp</a></li>
<li>sde/submodule_request.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
