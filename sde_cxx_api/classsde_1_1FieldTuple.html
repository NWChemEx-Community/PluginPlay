<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sde: sde::FieldTuple&lt; ElementType, FieldTypes &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sde</b></li><li class="navelem"><a class="el" href="classsde_1_1FieldTuple.html">FieldTuple</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classsde_1_1FieldTuple-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sde::FieldTuple&lt; ElementType, FieldTypes &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Forward declare <a class="el" href="classsde_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type. ">FieldTuple</a> so we can use the type.  
 <a href="classsde_1_1FieldTuple.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="field__tuple__traits_8hpp_source.html">field_tuple_traits.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a8ad3834169fb9249f7c6dfd4c2f83d44"><td class="memItemLeft" align="right" valign="top"><a id="a8ad3834169fb9249f7c6dfd4c2f83d44"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#a8ad3834169fb9249f7c6dfd4c2f83d44">traits_type</a> = <a class="el" href="structsde_1_1detail___1_1FieldTupleTraits.html">detail_::FieldTupleTraits</a>&lt; ElementType, FieldTypes... &gt;</td></tr>
<tr class="memdesc:a8ad3834169fb9249f7c6dfd4c2f83d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the traits class. <br /></td></tr>
<tr class="separator:a8ad3834169fb9249f7c6dfd4c2f83d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2adfa8925a2bf3e6e1342593f477bd8"><td class="memItemLeft" align="right" valign="top"><a id="ad2adfa8925a2bf3e6e1342593f477bd8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#ad2adfa8925a2bf3e6e1342593f477bd8">key_type</a> = typename <a class="el" href="structsde_1_1detail___1_1FieldTupleTraits.html#a9ded7e4013c6d0a5e1ad7a20bfb2049a">traits_type::key_type</a></td></tr>
<tr class="memdesc:ad2adfa8925a2bf3e6e1342593f477bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a key used to retrieve a field. <br /></td></tr>
<tr class="separator:ad2adfa8925a2bf3e6e1342593f477bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb86258db60c44ecd26d8e99f609f9f"><td class="memItemLeft" align="right" valign="top"><a id="a9eb86258db60c44ecd26d8e99f609f9f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#a9eb86258db60c44ecd26d8e99f609f9f">mapped_type</a> = typename <a class="el" href="structsde_1_1detail___1_1FieldTupleTraits.html#ac093122ec93fabccb2c48e0766ca7174">traits_type::mapped_type</a></td></tr>
<tr class="memdesc:a9eb86258db60c44ecd26d8e99f609f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the field. <br /></td></tr>
<tr class="separator:a9eb86258db60c44ecd26d8e99f609f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9f2841ad62f17cedaa03b0f564b607"><td class="memItemLeft" align="right" valign="top"><a id="a7c9f2841ad62f17cedaa03b0f564b607"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#a7c9f2841ad62f17cedaa03b0f564b607">value_type</a> = typename <a class="el" href="structsde_1_1detail___1_1FieldTupleTraits.html#a809ccad250a4946994a0c504e681cace">traits_type::value_type</a></td></tr>
<tr class="memdesc:a7c9f2841ad62f17cedaa03b0f564b607"><td class="mdescLeft">&#160;</td><td class="mdescRight">How we're storing the key-value pair, name from std::map. <br /></td></tr>
<tr class="separator:a7c9f2841ad62f17cedaa03b0f564b607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161b86392036395ba17d87f37b11a8a2"><td class="memItemLeft" align="right" valign="top"><a id="a161b86392036395ba17d87f37b11a8a2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#a161b86392036395ba17d87f37b11a8a2">iterator</a> = typename <a class="el" href="structsde_1_1detail___1_1FieldTupleTraits.html#adb8d6f6e7a0e2db9fd73be7b1e02870a">traits_type::iterator</a></td></tr>
<tr class="memdesc:a161b86392036395ba17d87f37b11a8a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a read/write iterator over this class. <br /></td></tr>
<tr class="separator:a161b86392036395ba17d87f37b11a8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc511c92f58ebfba5399f8765c0ac49"><td class="memItemLeft" align="right" valign="top"><a id="a3cc511c92f58ebfba5399f8765c0ac49"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#a3cc511c92f58ebfba5399f8765c0ac49">const_iterator</a> = typename <a class="el" href="structsde_1_1detail___1_1FieldTupleTraits.html#ac6b412aa7c426babf778d64b757c2031">traits_type::const_iterator</a></td></tr>
<tr class="memdesc:a3cc511c92f58ebfba5399f8765c0ac49"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a read-only iterator. <br /></td></tr>
<tr class="separator:a3cc511c92f58ebfba5399f8765c0ac49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e951b69feafdfbd4e847d321b944c38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#a5e951b69feafdfbd4e847d321b944c38">~FieldTuple</a> ()=default</td></tr>
<tr class="memdesc:a5e951b69feafdfbd4e847d321b944c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard dtor.  <a href="#a5e951b69feafdfbd4e847d321b944c38">More...</a><br /></td></tr>
<tr class="separator:a5e951b69feafdfbd4e847d321b944c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539a1012058805e197304595759172c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa539a1012058805e197304595759172c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#aa539a1012058805e197304595759172c">add_field</a> (<a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> key)</td></tr>
<tr class="memdesc:aa539a1012058805e197304595759172c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another field to the API.  <a href="#aa539a1012058805e197304595759172c">More...</a><br /></td></tr>
<tr class="separator:aa539a1012058805e197304595759172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9894ccedab786d4b373b99ba8949ca95"><td class="memTemplParams" colspan="2"><a id="a9894ccedab786d4b373b99ba8949ca95"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9894ccedab786d4b373b99ba8949ca95"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_field</b> (<a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> key, U &amp;&amp;value)</td></tr>
<tr class="separator:a9894ccedab786d4b373b99ba8949ca95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91a275c38110c95cccadd8851505bbe"><td class="memTemplParams" colspan="2"><a id="af91a275c38110c95cccadd8851505bbe"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af91a275c38110c95cccadd8851505bbe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>set_default</b> (T &amp;&amp;value)</td></tr>
<tr class="separator:af91a275c38110c95cccadd8851505bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600ee1d7132036a266fe9cb8e64b61a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesde_1_1type.html#a8ea5d692491ba6f4f58c376cb789ceb7">type::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#a600ee1d7132036a266fe9cb8e64b61a3">count</a> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key) const noexcept</td></tr>
<tr class="memdesc:a600ee1d7132036a266fe9cb8e64b61a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the number of fields with a particular key.  <a href="#a600ee1d7132036a266fe9cb8e64b61a3">More...</a><br /></td></tr>
<tr class="separator:a600ee1d7132036a266fe9cb8e64b61a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Ctor and assignment operators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The functions in this section can be used to create a new instance with a specified state or set the current instance to the state of another instance. Since we need to keep track of the type of each field it is only possible to modify the values held in the object and not to add more. Adding another field requires creating a new instance, which is done with the <code>add_field</code> member.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The instance to copy/move the state from. For move operations <code>rhs</code> is in a valid, but otherwise undefined state after the operation. </td></tr>
    <tr><td class="paramname">values</td><td>For 6, this array contains the values of each field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>assignment operators return the current instance with the state set to/taken from the other instance. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>copy operations throw if there is insufficient memory to copy a field instance's state. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">none</td><td>1, and 4-6 are all no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:ad9eedafde254ef8cee3f581195f348d7"><td class="memItemLeft" align="right" valign="top"><a id="ad9eedafde254ef8cee3f581195f348d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldTuple</b> ()=default</td></tr>
<tr class="separator:ad9eedafde254ef8cee3f581195f348d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a494d69d8f45dd50ce44efe11e1d25abc"><td class="memItemLeft" align="right" valign="top"><a id="a494d69d8f45dd50ce44efe11e1d25abc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldTuple</b> (const <a class="el" href="classsde_1_1FieldTuple.html">FieldTuple</a> &amp;rhs)=default</td></tr>
<tr class="separator:a494d69d8f45dd50ce44efe11e1d25abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2aef421778de4fcf2b4d127129c86d"><td class="memItemLeft" align="right" valign="top"><a id="aad2aef421778de4fcf2b4d127129c86d"></a>
<a class="el" href="classsde_1_1FieldTuple.html">FieldTuple</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classsde_1_1FieldTuple.html">FieldTuple</a> &amp;rhs)=default</td></tr>
<tr class="separator:aad2aef421778de4fcf2b4d127129c86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2196950b84982b5bf9ba6bbf1cf9d63"><td class="memItemLeft" align="right" valign="top"><a id="ad2196950b84982b5bf9ba6bbf1cf9d63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldTuple</b> (<a class="el" href="classsde_1_1FieldTuple.html">FieldTuple</a> &amp;&amp;rhs)=default</td></tr>
<tr class="separator:ad2196950b84982b5bf9ba6bbf1cf9d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc494f8d548bfa6354b9114eceb7402"><td class="memItemLeft" align="right" valign="top"><a id="a0fc494f8d548bfa6354b9114eceb7402"></a>
<a class="el" href="classsde_1_1FieldTuple.html">FieldTuple</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classsde_1_1FieldTuple.html">FieldTuple</a> &amp;&amp;rhs)=default</td></tr>
<tr class="separator:a0fc494f8d548bfa6354b9114eceb7402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916d3d1f8b024bbe51b6779382b28bbf"><td class="memItemLeft" align="right" valign="top"><a id="a916d3d1f8b024bbe51b6779382b28bbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>FieldTuple</b> (std::array&lt; <a class="el" href="classsde_1_1FieldTuple.html#a7c9f2841ad62f17cedaa03b0f564b607">value_type</a>, <a class="el" href="structsde_1_1detail___1_1FieldTupleTraits.html#a478df0d02617bed672b5e275f24cffe7">traits_type::nfields</a> &gt; values) noexcept</td></tr>
<tr class="separator:a916d3d1f8b024bbe51b6779382b28bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Field accessors</div></td></tr>
<tr class="memitem:a0bb2efffd32000edc6283c527930102a"><td class="memItemLeft" align="right" valign="top"><a id="a0bb2efffd32000edc6283c527930102a"></a>
auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="separator:a0bb2efffd32000edc6283c527930102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af114890b78ec000d64305be8fb053e"><td class="memItemLeft" align="right" valign="top"><a id="a3af114890b78ec000d64305be8fb053e"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key) const</td></tr>
<tr class="separator:a3af114890b78ec000d64305be8fb053e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0841a58c4c02c5cc7305d71e967e236e"><td class="memItemLeft" align="right" valign="top"><a id="a0841a58c4c02c5cc7305d71e967e236e"></a>
auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key)</td></tr>
<tr class="separator:a0841a58c4c02c5cc7305d71e967e236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edfdb6de57952e190f0c8a72bbd1f82"><td class="memItemLeft" align="right" valign="top"><a id="a9edfdb6de57952e190f0c8a72bbd1f82"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>at</b> (const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;key) const</td></tr>
<tr class="separator:a9edfdb6de57952e190f0c8a72bbd1f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The functions in this section can be used to retrieve iterators that run over the instance. Iterators are bidirectional. Variants 1 and 4 return iterators that can be used to read or modify the fields, wheras all other variants return read-only iterators. The first three variants return an iterator pointing at the first field in the API and the last three return an iterator just past the last field in the API.</p>
<dl class="section return"><dt>Returns</dt><dd>the requested iterator. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>
</div></td></tr>
<tr class="memitem:abdaa2ae9d69e51770af2302a32af428c"><td class="memItemLeft" align="right" valign="top"><a id="abdaa2ae9d69e51770af2302a32af428c"></a>
<a class="el" href="classsde_1_1FieldTuple.html#a161b86392036395ba17d87f37b11a8a2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () noexcept</td></tr>
<tr class="separator:abdaa2ae9d69e51770af2302a32af428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d6ba3e97fdcdd8733b024536dafb4b"><td class="memItemLeft" align="right" valign="top"><a id="a27d6ba3e97fdcdd8733b024536dafb4b"></a>
<a class="el" href="classsde_1_1FieldTuple.html#a3cc511c92f58ebfba5399f8765c0ac49">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const noexcept</td></tr>
<tr class="separator:a27d6ba3e97fdcdd8733b024536dafb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08503c2b3f0d49a982b6c95d1650f91e"><td class="memItemLeft" align="right" valign="top"><a id="a08503c2b3f0d49a982b6c95d1650f91e"></a>
<a class="el" href="classsde_1_1FieldTuple.html#a3cc511c92f58ebfba5399f8765c0ac49">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const noexcept</td></tr>
<tr class="separator:a08503c2b3f0d49a982b6c95d1650f91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de27e7cf905bf697cafc449347e7d8a"><td class="memItemLeft" align="right" valign="top"><a id="a7de27e7cf905bf697cafc449347e7d8a"></a>
<a class="el" href="classsde_1_1FieldTuple.html#a161b86392036395ba17d87f37b11a8a2">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () noexcept</td></tr>
<tr class="separator:a7de27e7cf905bf697cafc449347e7d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe5b625e152e5ac9f61a7bd296785a"><td class="memItemLeft" align="right" valign="top"><a id="af1fe5b625e152e5ac9f61a7bd296785a"></a>
<a class="el" href="classsde_1_1FieldTuple.html#a3cc511c92f58ebfba5399f8765c0ac49">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const noexcept</td></tr>
<tr class="separator:af1fe5b625e152e5ac9f61a7bd296785a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3e9da8009f81abf070eb6ee5ea5902"><td class="memItemLeft" align="right" valign="top"><a id="aae3e9da8009f81abf070eb6ee5ea5902"></a>
<a class="el" href="classsde_1_1FieldTuple.html#a3cc511c92f58ebfba5399f8765c0ac49">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const noexcept</td></tr>
<tr class="separator:aae3e9da8009f81abf070eb6ee5ea5902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aabd22b13750cb816d10ce87132e9b32e"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="namespacesde_1_1type.html#a8ea5d692491ba6f4f58c376cb789ceb7">type::size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1FieldTuple.html#aabd22b13750cb816d10ce87132e9b32e">size</a> () noexcept</td></tr>
<tr class="memdesc:aabd22b13750cb816d10ce87132e9b32e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of fields.  <a href="#aabd22b13750cb816d10ce87132e9b32e">More...</a><br /></td></tr>
<tr class="separator:aabd22b13750cb816d10ce87132e9b32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ElementType, typename... FieldTypes&gt;<br />
class sde::FieldTuple&lt; ElementType, FieldTypes &gt;</h3>

<p>Forward declare <a class="el" href="classsde_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type. ">FieldTuple</a> so we can use the type. </p>
<p>Records the property type's input or result API.</p>
<p>This class is responsible for holding the details of a property type's input or result fields. In particular this means that the class must retain:</p><ul>
<li>the order the fields were declared in,</li>
<li>the key for each field,</li>
<li>the type of each field's value, and</li>
<li>an input field's default value (only inputs may have default values)</li>
</ul>
<p>The <a class="el" href="classsde_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type. ">FieldTuple</a> class works like a map from a field's name to either a <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> or <a class="el" href="classsde_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function. ">ModuleResult</a> instance (depending respectively on whether the instance is storing the inputs to or the results from calling a module).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ElementType</td><td>This will be either <a class="el" href="classsde_1_1ModuleInput.html" title="Holds an input value for a module in a type-erased form. ">ModuleInput</a> or <a class="el" href="classsde_1_1ModuleResult.html" title="Holds the results of calling a module&#39;s run function. ">ModuleResult</a> depending on whether we are building the input or result API specification respectively. </td></tr>
    <tr><td class="paramname">FieldTypes</td><td>These are the types of the inputs/results in the order they are accepted/returned. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5e951b69feafdfbd4e847d321b944c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e951b69feafdfbd4e847d321b944c38">&#9670;&nbsp;</a></span>~FieldTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1FieldTuple.html">sde::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::~<a class="el" href="classsde_1_1FieldTuple.html">FieldTuple</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard dtor. </p>
<p>After calling this function all references are invalidated.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa539a1012058805e197304595759172c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa539a1012058805e197304595759172c">&#9670;&nbsp;</a></span>add_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classsde_1_1FieldTuple.html">sde::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::add_field </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds another field to the API. </p>
<p>This function adds another field to the property type's API. In order to store the type of the new field the type of this class must change, which can only be done by making a new instance (with a new type). This function will make that new instance, move this instance's state to the new instance, and then return the new instance. After calling this function the current instance will be in a valid, but otherwise undefined state. References to the state of each field are still valid, but references to a field are not.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the field you are adding. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The keyword to associate with this field. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new <a class="el" href="classsde_1_1FieldTuple.html" title="Forward declare FieldTuple so we can use the type. ">FieldTuple</a> instance which in </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is not enough memory to create the new field. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the provided key is already in use by another field. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a600ee1d7132036a266fe9cb8e64b61a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600ee1d7132036a266fe9cb8e64b61a3">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesde_1_1type.html#a8ea5d692491ba6f4f58c376cb789ceb7">type::size</a> <a class="el" href="classsde_1_1FieldTuple.html">sde::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacesde_1_1type.html#aec6154ffec1beb9ab777e4686721ba95">type::key</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the number of fields with a particular key. </p>
<p>We require that each field have a unique keyword associated with it, hence this function can only return 0 or 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key we are looking for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if the instance contains a field with a keyword <code>key</code> and 0 otherwise. </dd></dl>

</div>
</div>
<a id="aabd22b13750cb816d10ce87132e9b32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd22b13750cb816d10ce87132e9b32e">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ElementType , typename... FieldTypes&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="namespacesde_1_1type.html#a8ea5d692491ba6f4f58c376cb789ceb7">type::size</a> <a class="el" href="classsde_1_1FieldTuple.html">sde::FieldTuple</a>&lt; ElementType, FieldTypes &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of fields. </p>
<p>This is really a convenience function/prettier API since the number of fields can be read off the type.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of fields </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">none</td><td>no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>sde/detail_/<a class="el" href="field__tuple__traits_8hpp_source.html">field_tuple_traits.hpp</a></li>
<li>sde/<a class="el" href="field__tuple_8hpp_source.html">field_tuple.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
