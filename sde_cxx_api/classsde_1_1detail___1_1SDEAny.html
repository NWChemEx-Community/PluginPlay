<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sde: sde::detail_::SDEAny Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sde
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sde</b></li><li class="navelem"><b>detail_</b></li><li class="navelem"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classsde_1_1detail___1_1SDEAny-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sde::detail_::SDEAny Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> class is capable of holding an instance of any type in a type-safe manner.  
 <a href="classsde_1_1detail___1_1SDEAny.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="sde__any_8hpp_source.html">sde_any.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1267ae94657a40bd72ddcbb6db4e441e"><td class="memItemLeft" align="right" valign="top"><a id="a1267ae94657a40bd72ddcbb6db4e441e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a1267ae94657a40bd72ddcbb6db4e441e">rtti_type</a> = typename <a class="el" href="classsde_1_1detail___1_1SDEAnyWrapperBase.html#abab89926fdacd98002d4230f1e594879">SDEAnyWrapperBase::rtti_type</a></td></tr>
<tr class="memdesc:a1267ae94657a40bd72ddcbb6db4e441e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of rtti returned by the <code>type</code> function. <br /></td></tr>
<tr class="separator:a1267ae94657a40bd72ddcbb6db4e441e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af770f956e044c65197b2aed8a8f9c580"><td class="memItemLeft" align="right" valign="top"><a id="af770f956e044c65197b2aed8a8f9c580"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#af770f956e044c65197b2aed8a8f9c580">wrapper_ptr</a> = typename <a class="el" href="classsde_1_1detail___1_1SDEAnyWrapperBase.html#accb8a3a7028e8e9f6598d748f229f686">SDEAnyWrapperBase::wrapper_ptr</a></td></tr>
<tr class="memdesc:af770f956e044c65197b2aed8a8f9c580"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the pointer holding the value. <br /></td></tr>
<tr class="separator:af770f956e044c65197b2aed8a8f9c580"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1af7297dec502f12962a78da9ecb9ad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a1af7297dec502f12962a78da9ecb9ad5">SDEAny</a> () noexcept=default</td></tr>
<tr class="memdesc:a1af7297dec502f12962a78da9ecb9ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an empty <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance.  <a href="#a1af7297dec502f12962a78da9ecb9ad5">More...</a><br /></td></tr>
<tr class="separator:a1af7297dec502f12962a78da9ecb9ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea33c471596fb46dadff3733a2b2913c"><td class="memTemplParams" colspan="2">template&lt;typename T , enable_if_not_an_any_t&lt; T &gt;  = 0&gt; </td></tr>
<tr class="memitem:aea33c471596fb46dadff3733a2b2913c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#aea33c471596fb46dadff3733a2b2913c">SDEAny</a> (T &amp;&amp;value)</td></tr>
<tr class="memdesc:aea33c471596fb46dadff3733a2b2913c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to construct an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance holding a particular value.  <a href="#aea33c471596fb46dadff3733a2b2913c">More...</a><br /></td></tr>
<tr class="separator:aea33c471596fb46dadff3733a2b2913c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8445416746046af8667d51baca8c5c98"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a8445416746046af8667d51baca8c5c98">SDEAny</a> (const <a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;rhs)</td></tr>
<tr class="memdesc:a8445416746046af8667d51baca8c5c98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a new <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance by deep copying the instance wrapped in another <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance.  <a href="#a8445416746046af8667d51baca8c5c98">More...</a><br /></td></tr>
<tr class="separator:a8445416746046af8667d51baca8c5c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a70b7d2a31204ef3060b13371a09df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a0a70b7d2a31204ef3060b13371a09df8">operator=</a> (const <a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;r)</td></tr>
<tr class="memdesc:a0a70b7d2a31204ef3060b13371a09df8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current instance to a copy of another instance.  <a href="#a0a70b7d2a31204ef3060b13371a09df8">More...</a><br /></td></tr>
<tr class="separator:a0a70b7d2a31204ef3060b13371a09df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c998753de73f51e2cbb8fc5f676f09"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#ab4c998753de73f51e2cbb8fc5f676f09">SDEAny</a> (<a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&amp;rhs) noexcept=default</td></tr>
<tr class="memdesc:ab4c998753de73f51e2cbb8fc5f676f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes the current <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance to take ownership of another instance.  <a href="#ab4c998753de73f51e2cbb8fc5f676f09">More...</a><br /></td></tr>
<tr class="separator:ab4c998753de73f51e2cbb8fc5f676f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8d2ca64db71db4a4d8404e16eb2721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a5c8d2ca64db71db4a4d8404e16eb2721">operator=</a> (<a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&amp;rhs) noexcept=default</td></tr>
<tr class="memdesc:a5c8d2ca64db71db4a4d8404e16eb2721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current instance to the state of another <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance.  <a href="#a5c8d2ca64db71db4a4d8404e16eb2721">More...</a><br /></td></tr>
<tr class="separator:a5c8d2ca64db71db4a4d8404e16eb2721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71791963ffaee48ffd9d98a1cd71bc61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a71791963ffaee48ffd9d98a1cd71bc61">~SDEAny</a> ()=default</td></tr>
<tr class="memdesc:a71791963ffaee48ffd9d98a1cd71bc61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up the memory wrapped by the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance.  <a href="#a71791963ffaee48ffd9d98a1cd71bc61">More...</a><br /></td></tr>
<tr class="separator:a71791963ffaee48ffd9d98a1cd71bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317d5e79bc3ea0b22170c8a7b0b9a7be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a317d5e79bc3ea0b22170c8a7b0b9a7be"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a317d5e79bc3ea0b22170c8a7b0b9a7be">emplace</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a317d5e79bc3ea0b22170c8a7b0b9a7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the wrapped value by forwarding the provided arguments to the wrapped value's constructor.  <a href="#a317d5e79bc3ea0b22170c8a7b0b9a7be">More...</a><br /></td></tr>
<tr class="separator:a317d5e79bc3ea0b22170c8a7b0b9a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4bc8d35184134b98dd2cdd0b75533f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#aec4bc8d35184134b98dd2cdd0b75533f">reset</a> () noexcept</td></tr>
<tr class="memdesc:aec4bc8d35184134b98dd2cdd0b75533f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the wrapped value freeing up the memory associated with it.  <a href="#aec4bc8d35184134b98dd2cdd0b75533f">More...</a><br /></td></tr>
<tr class="separator:aec4bc8d35184134b98dd2cdd0b75533f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b145ac5463eafe6310cf73acf9bcd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a52b145ac5463eafe6310cf73acf9bcd8">swap</a> (<a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;rhs) noexcept</td></tr>
<tr class="memdesc:a52b145ac5463eafe6310cf73acf9bcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the states of two <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances.  <a href="#a52b145ac5463eafe6310cf73acf9bcd8">More...</a><br /></td></tr>
<tr class="separator:a52b145ac5463eafe6310cf73acf9bcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d88805cf379a8c25412c452be2e35b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3d88805cf379a8c25412c452be2e35b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#aa3d88805cf379a8c25412c452be2e35b">cast</a> ()</td></tr>
<tr class="memdesc:aa3d88805cf379a8c25412c452be2e35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to retrieve the value wrapped in the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a>.  <a href="#aa3d88805cf379a8c25412c452be2e35b">More...</a><br /></td></tr>
<tr class="separator:aa3d88805cf379a8c25412c452be2e35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f989fca4baa7d4737bb653373fd9b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99f989fca4baa7d4737bb653373fd9b1"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a99f989fca4baa7d4737bb653373fd9b1">cast</a> () const</td></tr>
<tr class="memdesc:a99f989fca4baa7d4737bb653373fd9b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to retrieve the value wrapped in a read-only <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a>.  <a href="#a99f989fca4baa7d4737bb653373fd9b1">More...</a><br /></td></tr>
<tr class="separator:a99f989fca4baa7d4737bb653373fd9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f429e282471fa9c9700a7aeb255f9b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a0f429e282471fa9c9700a7aeb255f9b0">has_value</a> () const noexcept</td></tr>
<tr class="memdesc:a0f429e282471fa9c9700a7aeb255f9b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the current <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance is presently wrapping a value.  <a href="#a0f429e282471fa9c9700a7aeb255f9b0">More...</a><br /></td></tr>
<tr class="separator:a0f429e282471fa9c9700a7aeb255f9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d5def90426230ce65ea1d0e63007eb"><td class="memTemplParams" colspan="2"><a id="a85d5def90426230ce65ea1d0e63007eb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85d5def90426230ce65ea1d0e63007eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_convertible</b> () const</td></tr>
<tr class="separator:a85d5def90426230ce65ea1d0e63007eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e95ee2cbd8895929d9a7287571a5b70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a1267ae94657a40bd72ddcbb6db4e441e">rtti_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a5e95ee2cbd8895929d9a7287571a5b70">type</a> () const noexcept</td></tr>
<tr class="memdesc:a5e95ee2cbd8895929d9a7287571a5b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the wrapped instance.  <a href="#a5e95ee2cbd8895929d9a7287571a5b70">More...</a><br /></td></tr>
<tr class="separator:a5e95ee2cbd8895929d9a7287571a5b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab87ca0ca33341618f8bedba667a1b83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#aab87ca0ca33341618f8bedba667a1b83">hash</a> (Hasher &amp;h) const</td></tr>
<tr class="memdesc:aab87ca0ca33341618f8bedba667a1b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forwards the wrapped type to the provided Hasher.  <a href="#aab87ca0ca33341618f8bedba667a1b83">More...</a><br /></td></tr>
<tr class="separator:aab87ca0ca33341618f8bedba667a1b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f9840c6813c4bde01eeaae8940a6b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a46f9840c6813c4bde01eeaae8940a6b4">str</a> () const</td></tr>
<tr class="memdesc:a46f9840c6813c4bde01eeaae8940a6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a human-readable string representation of the wrapped instance.  <a href="#a46f9840c6813c4bde01eeaae8940a6b4">More...</a><br /></td></tr>
<tr class="separator:a46f9840c6813c4bde01eeaae8940a6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb6bbe7b4f63646d0facc55fb4b0117"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a4bb6bbe7b4f63646d0facc55fb4b0117">operator==</a> (const <a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a4bb6bbe7b4f63646d0facc55fb4b0117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances for equality.  <a href="#a4bb6bbe7b4f63646d0facc55fb4b0117">More...</a><br /></td></tr>
<tr class="separator:a4bb6bbe7b4f63646d0facc55fb4b0117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e4916661b40fffd4958934efdd627a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#ab7e4916661b40fffd4958934efdd627a">operator!=</a> (const <a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:ab7e4916661b40fffd4958934efdd627a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances to see if they are different.  <a href="#ab7e4916661b40fffd4958934efdd627a">More...</a><br /></td></tr>
<tr class="separator:ab7e4916661b40fffd4958934efdd627a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a92eb86a0b51bb2f2f2a3cd0078bec612"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a92eb86a0b51bb2f2f2a3cd0078bec612"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a92eb86a0b51bb2f2f2a3cd0078bec612">SDEAnyCast</a> (U &amp;&amp;da_any)</td></tr>
<tr class="memdesc:a92eb86a0b51bb2f2f2a3cd0078bec612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the value wrapped in an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance.  <a href="#a92eb86a0b51bb2f2f2a3cd0078bec612">More...</a><br /></td></tr>
<tr class="separator:a92eb86a0b51bb2f2f2a3cd0078bec612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49209e94b9ba55903b1c718c7aa85fc8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a49209e94b9ba55903b1c718c7aa85fc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a49209e94b9ba55903b1c718c7aa85fc8">make_SDEAny</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a49209e94b9ba55903b1c718c7aa85fc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance by forwarding the arguments to the wrapped instance's constructor.  <a href="#a49209e94b9ba55903b1c718c7aa85fc8">More...</a><br /></td></tr>
<tr class="separator:a49209e94b9ba55903b1c718c7aa85fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> class is capable of holding an instance of any type in a type-safe manner. </p>
<p>This class is used extensively through the SDE to avoid needing to know the types of inputs and results to a property type or module API. Under the hood it works by wrapping an std::any and casting that any to implement the additional functions which are part of the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a>'s API, but not the std::any's API. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1af7297dec502f12962a78da9ecb9ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af7297dec502f12962a78da9ecb9ad5">&#9670;&nbsp;</a></span>SDEAny() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::SDEAny::SDEAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an empty <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance. </p>
<p>The resulting <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance wraps no object. An object can be added to this instance by calling the member function emplace, by assigning to this instance another <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance (containing a value), or by moving from another <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance containing a value.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea33c471596fb46dadff3733a2b2913c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea33c471596fb46dadff3733a2b2913c">&#9670;&nbsp;</a></span>SDEAny() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename SDEAny::enable_if_not_an_any_t&lt; T &gt; &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::SDEAny::SDEAny </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to construct an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance holding a particular value. </p>
<p>This ctor forwards the provided value to the underlying std::any. If an lvalue is provided a copy will be made.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the instance to wrap. Must be copyable, hashable, and have operator== defined. </td></tr>
    <tr><td class="paramname">&lt;anonymous&gt;</td><td>A dummy type used to implement SFINAE.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The instance to wrap. It will be forwarded to the underlying std::any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if memory allocation fails. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>If the copy/move constructor of <code>T</code> throws. Same guarantee as <code>T's</code> ctor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8445416746046af8667d51baca8c5c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8445416746046af8667d51baca8c5c98">&#9670;&nbsp;</a></span>SDEAny() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::SDEAny::SDEAny </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a new <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance by deep copying the instance wrapped in another <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance. </p>
<p>From the perspective of this class the copy ctor always makes a deep copy. Whether it actually is a deep copy or not depends on the copy constructor of the wrapped class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy the instance stored in <code>rhs</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>if the wrapped type's copy ctor throws. Same guarantee as the wrapped type's copy ctor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4c998753de73f51e2cbb8fc5f676f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4c998753de73f51e2cbb8fc5f676f09">&#9670;&nbsp;</a></span>SDEAny() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::SDEAny::SDEAny </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Causes the current <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance to take ownership of another instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance to take ownership of. After calling this constructor <code>rhs</code> is in a valid, but undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Data Races:</dt><dd>The contents of <code>rhs</code> are modified so attempts to concurrently access <code>rhs</code> may result in data races.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71791963ffaee48ffd9d98a1cd71bc61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71791963ffaee48ffd9d98a1cd71bc61">&#9670;&nbsp;</a></span>~SDEAny()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">sde::detail_::SDEAny::~SDEAny </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees up the memory wrapped by the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance. </p>
<p>This is a default dtor. After calling it all references to the underlying type-erased instance are no longer valid.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3d88805cf379a8c25412c452be2e35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d88805cf379a8c25412c452be2e35b">&#9670;&nbsp;</a></span>cast() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sde::detail_::SDEAny::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to retrieve the value wrapped in the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a>. </p>
<p>The canonical way to retrieve the value from an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> is to use SDEAnyCast. This function is the implementation for the cast and can be called directly if the user wants.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to cast the wrapped <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance to. Should include cv qualifiers and include reference/pointer designations if so desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped value as the requested type.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_any_cast</td><td>if the instance does not contain a wrapped value or if that wrapped value can not be converted to <code>T</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a99f989fca4baa7d4737bb653373fd9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f989fca4baa7d4737bb653373fd9b1">&#9670;&nbsp;</a></span>cast() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T sde::detail_::SDEAny::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used to retrieve the value wrapped in a read-only <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a>. </p>
<p>The canonical way to retrieve the value from an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> is to use SDEAnyCast. This function is the implementation for the cast and can be called directly if the user wants. This overload will only allow you to retrieve the value in a read-only state.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type to cast the wrapped <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance to. Should include cv qualifiers and include reference/pointer designations if so desired.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped value as the requested type.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_any_cast</td><td>if the instance does not contain a wrapped value or if that wrapped value can not be converted to <code>T</code>. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a317d5e79bc3ea0b22170c8a7b0b9a7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a317d5e79bc3ea0b22170c8a7b0b9a7be">&#9670;&nbsp;</a></span>emplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T &amp; sde::detail_::SDEAny::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the wrapped value by forwarding the provided arguments to the wrapped value's constructor. </p>
<p>This function can be used to change the instance wrapped inside this object. More specifically the arguments provided to this function are forwarded to <code>T's</code> constructor, and the resulting instance becomes the wrapped state (freeing up any existing state). Note the arguments can be a <code>T</code> instance in which case the copy or move constructor of <code>T</code> will be invoked.</p>
<p>This function is admittedly a bit intimidating until you see it in action. Let's say you have an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance and you want it to wrap a double, this could be done like:</p>
<div class="fragment"><div class="line"><a class="code" href="classsde_1_1detail___1_1SDEAny.html#a1af7297dec502f12962a78da9ecb9ad5">SDEAny</a> my_any;</div><div class="line"><span class="keywordtype">double</span>&amp; wrapped_value = my_any.emplace&lt;<span class="keywordtype">double</span>&gt;(3.14);</div></div><!-- fragment --><p>For a more complicated type, like an std::vector&lt;double&gt; we could instead do:</p>
<div class="fragment"><div class="line"><a class="code" href="classsde_1_1detail___1_1SDEAny.html#a1af7297dec502f12962a78da9ecb9ad5">SDEAny</a> my_any;</div><div class="line"><a class="code" href="namespacestd.html">std</a>:vector&lt;double&gt; vec1{1.1, 1.2, 1.3};</div><div class="line"></div><div class="line"><span class="comment">// Makes a copy of vec1</span></div><div class="line"><span class="keyword">auto</span>&amp; wrapped_ve1 = my_any.emplace&lt;std::vector&lt;double&gt;&gt;(vec1);</div><div class="line"></div><div class="line"><span class="comment">// ...makes vec1, inside the SDEANy, without the copy</span></div><div class="line"><span class="keyword">auto</span>&amp; wrapped_v2 = my_any.emplace&lt;std::vector&lt;double&gt;&gt;({1.1, 1.2, 1.3});</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object to wrap. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the arguments to forward to the <code>T's</code> constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The arguments to forward to <code>T's</code> constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Same as T's constructor.</dd></dl>
<dl class="section user"><dt>Data Races:</dt><dd>The state of the current instance is modified and a data race may occur if the current instance is concurrently accessed. Data races may also be present for <code>args</code> upon forwarding to T's constructor depending on T.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The wrapped instance by reference. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>If <code>T's</code> constructor throws given <code>args</code>. Same guarantee as T's constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f429e282471fa9c9700a7aeb255f9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f429e282471fa9c9700a7aeb255f9b0">&#9670;&nbsp;</a></span>has_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::SDEAny::has_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the current <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance is presently wrapping a value. </p>
<p>An <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> can either be holding a type-erased value or not. This function is used to determine which it is.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the current instance is holding a value and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant. </dd></dl>

</div>
</div>
<a id="aab87ca0ca33341618f8bedba667a1b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab87ca0ca33341618f8bedba667a1b83">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::SDEAny::hash </td>
          <td>(</td>
          <td class="paramtype">Hasher &amp;&#160;</td>
          <td class="paramname"><em>h</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forwards the wrapped type to the provided Hasher. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">h</td><td>A Hasher instance to use for the hashing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>if the wrapped instance's hash function throws. Same throw guarantee as the wrapped instance's hash function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Same as the complexity of hashing the wrapped type. </dd></dl>

</div>
</div>
<a id="ab7e4916661b40fffd4958934efdd627a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e4916661b40fffd4958934efdd627a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::SDEAny::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances to see if they are different. </p>
<p>Two <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances are equal if they both hold a value (or do not hold a value) and, in the case that they both hold a value, the wrapped values compare equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances are equal and true otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>All comparisons are no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a70b7d2a31204ef3060b13371a09df8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a70b7d2a31204ef3060b13371a09df8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a>&amp; sde::detail_::SDEAny::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current instance to a copy of another instance. </p>
<p>This function will call the copy constructor of the object wrapped by <code>rhs</code> and set the current instance's state to the result. The state before this call (if any) will be deleted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to deep copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance containing a copy of <code>rhs's</code> state.</dd></dl>
<dl class="section user"><dt>Complexity:</dt><dd>Same as the wrapped type.</dd></dl>
<dl class="section user"><dt>Data Races:</dt><dd>The current state is modified, meaning attempts to concurrently access it may lead to data races. Similarly the contents of <code>rhs</code> are accessed and concurrent modifications may lead to data races.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to copy the instance stored in <code>rhs</code>. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>if the wrapped type's constructor throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c8d2ca64db71db4a4d8404e16eb2721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8d2ca64db71db4a4d8404e16eb2721">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a>&amp; sde::detail_::SDEAny::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current instance to the state of another <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance we are taking the state of. After this call <code>rhs</code> is in a valid, but otherwise undefined state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Constant.</dd></dl>
<dl class="section user"><dt>Data Races:</dt><dd>The contents of both this instance and <code>rhs</code> are modified. Consequentially, attempts to concurrently access either instances' state may yield a data race.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The current instance possessing the state of <code>rhs</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4bb6bbe7b4f63646d0facc55fb4b0117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb6bbe7b4f63646d0facc55fb4b0117">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sde::detail_::SDEAny::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compares two <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances for equality. </p>
<p>Two <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances are equal if they both hold a value (or do not hold a value) and, in the case that they both hold a value, the wrapped values compare equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The instance to compare to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances are equal and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>All comparisons are no throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec4bc8d35184134b98dd2cdd0b75533f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4bc8d35184134b98dd2cdd0b75533f">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::SDEAny::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Releases the wrapped value freeing up the memory associated with it. </p>
<p><a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances own the memory they are wrapping. This member function can be used to release the memory before the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance goes out of scope. Following normal RAII practices the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> will release any held memory in its dtor meaning users need not call this function before letting an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance go out of scope.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46f9840c6813c4bde01eeaae8940a6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f9840c6813c4bde01eeaae8940a6b4">&#9670;&nbsp;</a></span>str()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string sde::detail_::SDEAny::str </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a human-readable string representation of the wrapped instance. </p>
<p>This function ultimately works by printing "&lt;empty SDEAny&gt;" if the current instance does not contain a value, or the result of forwarding the wrapped value to <code>std::ostream::operator&lt;&lt;</code>. Overloads of this operator for STL containers are leveraged.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory to create the string. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>if std::ostream&lt;&lt; throws when provided the wrapped value. Same guarantee as std::ostream&lt;&lt;. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52b145ac5463eafe6310cf73acf9bcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b145ac5463eafe6310cf73acf9bcd8">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sde::detail_::SDEAny::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the states of two <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instances. </p>
<p>After a call to this function, the current instance will contain <code>rhs's</code> state and <code>rhs</code> will contain the current instance's state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs</td><td>The <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance to swap contents with. After this call <code>rhs</code> will contain the current instance's state.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity constant.</dt><dd></dd></dl>

</div>
</div>
<a id="a5e95ee2cbd8895929d9a7287571a5b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e95ee2cbd8895929d9a7287571a5b70">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1detail___1_1SDEAny.html#a1267ae94657a40bd72ddcbb6db4e441e">SDEAny::rtti_type</a> sde::detail_::SDEAny::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the type of the wrapped instance. </p>
<p>This function returns the RTTI of the wrapped instance. It should be noted that the representation of the RTTI is compiler specific and should be used with caution. If the current instance is not wrapping anything the result will be typeid(void).</p>
<dl class="section return"><dt>Returns</dt><dd>The RTTI of the wrapped type. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None.</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a49209e94b9ba55903b1c718c7aa85fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49209e94b9ba55903b1c718c7aa85fc8">&#9670;&nbsp;</a></span>make_SDEAny()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsde_1_1detail___1_1SDEAny.html">SDEAny</a> make_SDEAny </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance by forwarding the arguments to the wrapped instance's constructor. </p>
<p>This is a convenience function for directly populating an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance so that the user does not have to first construct a temporary and then forward that temporary to an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object that the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> should wrap. </td></tr>
    <tr><td class="paramname">Args</td><td>The types of the arguments that are being forwarded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">args</td><td>The values to forward to <code>T's</code> ctor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance containing a newly created wrapped <code>T</code> instance.</dd></dl>
<dl class="section user"><dt>Data Races:</dt><dd>The values of <code>args</code> are forwarded to T's ctor and data races may occur if the values of args are concurrently modified.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is insufficient memory for the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> to create the wrapper. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>If <code>T's</code> constructor throws. Same guarantee as T's constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity:</dt><dd>Same as T's ctor taking <code>args</code>. </dd></dl>

</div>
</div>
<a id="a92eb86a0b51bb2f2f2a3cd0078bec612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92eb86a0b51bb2f2f2a3cd0078bec612">&#9670;&nbsp;</a></span>SDEAnyCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T SDEAnyCast </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>da_any</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the value wrapped in an <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value wrapped in the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance. </td></tr>
    <tr><td class="paramname">U</td><td>The type of the <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance itself. Should be at most cv-qualified <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">da_any</td><td>The <a class="el" href="classsde_1_1detail___1_1SDEAny.html" title="The SDEAny class is capable of holding an instance of any type in a type-safe manner. ">SDEAny</a> instance to retrieve the value from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value wrapped by <code>da_any</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_any_cast</td><td>if the value wrapped by <code>da_any</code> is not convertible to type <code>T</code> or if <code>da_any</code> does not contain a value. Strong throw guarantee.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Complexity: Constant.</dt><dd></dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>sde/detail_/<a class="el" href="sde__any_8hpp_source.html">sde_any.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
