<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>pluginplay: pluginplay::Cache Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">pluginplay
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>pluginplay</b></li><li class="navelem"><a class="el" href="classpluginplay_1_1Cache.html">Cache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classpluginplay_1_1Cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">pluginplay::Cache Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>An object for storing data which may be needed after a module has run.  
 <a href="classpluginplay_1_1Cache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cache_8hpp_source.html">cache.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af69d1d916bd054028a21dd73acdc2cff"><td class="memItemLeft" align="right" valign="top"><a id="af69d1d916bd054028a21dd73acdc2cff"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> = std::string</td></tr>
<tr class="memdesc:af69d1d916bd054028a21dd73acdc2cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type used for a "key". <br /></td></tr>
<tr class="separator:af69d1d916bd054028a21dd73acdc2cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac29bb37a478aea8db216499820abd1ab"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename  = disable_if_hash_t&lt;KeyType&gt;&gt; </td></tr>
<tr class="memitem:ac29bb37a478aea8db216499820abd1ab"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#ac29bb37a478aea8db216499820abd1ab">count</a> (const KeyType &amp;key) const</td></tr>
<tr class="memdesc:ac29bb37a478aea8db216499820abd1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the cache stores a value associated with the provided key.  <a href="classpluginplay_1_1Cache.html#ac29bb37a478aea8db216499820abd1ab">More...</a><br /></td></tr>
<tr class="separator:ac29bb37a478aea8db216499820abd1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23113a1e7ce07656e122e3e8c3a20da6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a23113a1e7ce07656e122e3e8c3a20da6">count</a> (const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;key) const noexcept</td></tr>
<tr class="memdesc:a23113a1e7ce07656e122e3e8c3a20da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether or not the cache stores a value associated with the provided hash.  <a href="classpluginplay_1_1Cache.html#a23113a1e7ce07656e122e3e8c3a20da6">More...</a><br /></td></tr>
<tr class="separator:a23113a1e7ce07656e122e3e8c3a20da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1c0401808d986be8bc7edfd2ee578"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename ValueType , typename  = disable_if_hash_t&lt;KeyType&gt;&gt; </td></tr>
<tr class="memitem:a97a1c0401808d986be8bc7edfd2ee578"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a97a1c0401808d986be8bc7edfd2ee578">cache</a> (const KeyType &amp;key, ValueType &amp;&amp;value, const CacheTag &amp;tag=CacheTag::Permenant)</td></tr>
<tr class="memdesc:a97a1c0401808d986be8bc7edfd2ee578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a value under the provided key.  <a href="classpluginplay_1_1Cache.html#a97a1c0401808d986be8bc7edfd2ee578">More...</a><br /></td></tr>
<tr class="separator:a97a1c0401808d986be8bc7edfd2ee578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b9c0dd90feffb3569b728f33e01869"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a29b9c0dd90feffb3569b728f33e01869"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a29b9c0dd90feffb3569b728f33e01869">cache</a> (<a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> key, ValueType &amp;&amp;value, const CacheTag &amp;tag=CacheTag::Permenant)</td></tr>
<tr class="memdesc:a29b9c0dd90feffb3569b728f33e01869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a value under the provided hash value.  <a href="classpluginplay_1_1Cache.html#a29b9c0dd90feffb3569b728f33e01869">More...</a><br /></td></tr>
<tr class="separator:a29b9c0dd90feffb3569b728f33e01869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee18aa2136878476b64e1a21ef12967"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename KeyType , typename  = disable_if_hash_t&lt;KeyType&gt;&gt; </td></tr>
<tr class="memitem:a1ee18aa2136878476b64e1a21ef12967"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a1ee18aa2136878476b64e1a21ef12967">uncache</a> (const KeyType &amp;key)</td></tr>
<tr class="memdesc:a1ee18aa2136878476b64e1a21ef12967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing cached data by key.  <a href="classpluginplay_1_1Cache.html#a1ee18aa2136878476b64e1a21ef12967">More...</a><br /></td></tr>
<tr class="separator:a1ee18aa2136878476b64e1a21ef12967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3408d24a371c85c10c8fd6d3bdfee381"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a3408d24a371c85c10c8fd6d3bdfee381"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a3408d24a371c85c10c8fd6d3bdfee381">uncache</a> (const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;key)</td></tr>
<tr class="memdesc:a3408d24a371c85c10c8fd6d3bdfee381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing cached data by hash.  <a href="classpluginplay_1_1Cache.html#a3408d24a371c85c10c8fd6d3bdfee381">More...</a><br /></td></tr>
<tr class="separator:a3408d24a371c85c10c8fd6d3bdfee381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306e47d5dd610d21d41e2755f4ecfefd"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename KeyType , typename  = disable_if_hash_t&lt;KeyType&gt;&gt; </td></tr>
<tr class="memitem:a306e47d5dd610d21d41e2755f4ecfefd"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a306e47d5dd610d21d41e2755f4ecfefd">uncache</a> (const KeyType &amp;key) const</td></tr>
<tr class="memdesc:a306e47d5dd610d21d41e2755f4ecfefd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing read-only cached data by key.  <a href="classpluginplay_1_1Cache.html#a306e47d5dd610d21d41e2755f4ecfefd">More...</a><br /></td></tr>
<tr class="separator:a306e47d5dd610d21d41e2755f4ecfefd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1857e470ac0ff0928bced67ca0190e"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a2a1857e470ac0ff0928bced67ca0190e"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a2a1857e470ac0ff0928bced67ca0190e">uncache</a> (const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;key) const</td></tr>
<tr class="memdesc:a2a1857e470ac0ff0928bced67ca0190e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing read-only cached data by hash.  <a href="classpluginplay_1_1Cache.html#a2a1857e470ac0ff0928bced67ca0190e">More...</a><br /></td></tr>
<tr class="separator:a2a1857e470ac0ff0928bced67ca0190e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19f86c272bb6a237b6472ec571d6063"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename KeyType , typename  = disable_if_hash_t&lt;KeyType&gt;&gt; </td></tr>
<tr class="memitem:aa19f86c272bb6a237b6472ec571d6063"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#aa19f86c272bb6a237b6472ec571d6063">uncache</a> (const KeyType &amp;key, const ValueType &amp;default_value)</td></tr>
<tr class="memdesc:aa19f86c272bb6a237b6472ec571d6063"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing cached data by key, return default value if not cached.  <a href="classpluginplay_1_1Cache.html#aa19f86c272bb6a237b6472ec571d6063">More...</a><br /></td></tr>
<tr class="separator:aa19f86c272bb6a237b6472ec571d6063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcbffb3faea295043a243e719f26df5"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a4fcbffb3faea295043a243e719f26df5"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a4fcbffb3faea295043a243e719f26df5">uncache</a> (const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;key, const ValueType &amp;default_value)</td></tr>
<tr class="memdesc:a4fcbffb3faea295043a243e719f26df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing cached data by hash, return default value if not cached.  <a href="classpluginplay_1_1Cache.html#a4fcbffb3faea295043a243e719f26df5">More...</a><br /></td></tr>
<tr class="separator:a4fcbffb3faea295043a243e719f26df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a031d7fa11e4699129b8a50fef412f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename KeyType , typename  = disable_if_hash_t&lt;KeyType&gt;&gt; </td></tr>
<tr class="memitem:a52a031d7fa11e4699129b8a50fef412f"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a52a031d7fa11e4699129b8a50fef412f">uncache</a> (const KeyType &amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a52a031d7fa11e4699129b8a50fef412f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing read-only cached data by key, return default value if not cached.  <a href="classpluginplay_1_1Cache.html#a52a031d7fa11e4699129b8a50fef412f">More...</a><br /></td></tr>
<tr class="separator:a52a031d7fa11e4699129b8a50fef412f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53493d304fb88eed1041b841b7b3b26f"><td class="memTemplParams" colspan="2">template&lt;typename ValueType &gt; </td></tr>
<tr class="memitem:a53493d304fb88eed1041b841b7b3b26f"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a53493d304fb88eed1041b841b7b3b26f">uncache</a> (const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;key, const ValueType &amp;default_value) const</td></tr>
<tr class="memdesc:a53493d304fb88eed1041b841b7b3b26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function for accessing read-only cached data by hash, return default value if not cached.  <a href="classpluginplay_1_1Cache.html#a53493d304fb88eed1041b841b7b3b26f">More...</a><br /></td></tr>
<tr class="separator:a53493d304fb88eed1041b841b7b3b26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe00589b3a6338b98a41ba688f5cfd5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#acbe00589b3a6338b98a41ba688f5cfd5">set_temporary</a> (const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;key)</td></tr>
<tr class="memdesc:acbe00589b3a6338b98a41ba688f5cfd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a given cache key as temporary.  <a href="classpluginplay_1_1Cache.html#acbe00589b3a6338b98a41ba688f5cfd5">More...</a><br /></td></tr>
<tr class="separator:acbe00589b3a6338b98a41ba688f5cfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af203dd006b311660a1c6e067f34ff799"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#af203dd006b311660a1c6e067f34ff799">set_permanent</a> (const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;key)</td></tr>
<tr class="memdesc:af203dd006b311660a1c6e067f34ff799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a given cache key as permanent.  <a href="classpluginplay_1_1Cache.html#af203dd006b311660a1c6e067f34ff799">More...</a><br /></td></tr>
<tr class="separator:af203dd006b311660a1c6e067f34ff799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a6ec0338db4feb77f4fe5f2774d032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#aa7a6ec0338db4feb77f4fe5f2774d032">prune_cache</a> ()</td></tr>
<tr class="memdesc:aa7a6ec0338db4feb77f4fe5f2774d032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes temporary values in the cache.  <a href="classpluginplay_1_1Cache.html#aa7a6ec0338db4feb77f4fe5f2774d032">More...</a><br /></td></tr>
<tr class="separator:aa7a6ec0338db4feb77f4fe5f2774d032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6071ca40eeab03469beb59f828721ddb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classpluginplay_1_1Cache.html#a6071ca40eeab03469beb59f828721ddb">reset_cache</a> ()</td></tr>
<tr class="memdesc:a6071ca40eeab03469beb59f828721ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the module cache to an empty map.  <a href="classpluginplay_1_1Cache.html#a6071ca40eeab03469beb59f828721ddb">More...</a><br /></td></tr>
<tr class="separator:a6071ca40eeab03469beb59f828721ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An object for storing data which may be needed after a module has run. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a97a1c0401808d986be8bc7edfd2ee578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1c0401808d986be8bc7edfd2ee578">&#9670;&nbsp;</a></span>cache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename ValueType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::Cache::cache </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CacheTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>CacheTag::Permenant</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a value under the provided key. </p>
<p>This function is used to add data to the current <a class="el" href="classpluginplay_1_1Cache.html" title="An object for storing data which may be needed after a module has run.">Cache</a> instance. The data is associated with the provided object. While the API restricts the key to being a single object, <code>std::tuple</code> can be used to instead</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>The type of the object being used as a key. Must be hashable. </td></tr>
    <tr><td class="paramname">ValueType</td><td>The type of the data being stored. Must be type-erasable via an pluginplayAny. </td></tr>
    <tr><td class="paramname">&lt;Anonymous&gt;</td><td>Template type parameter used to disable overload when <code>KeyType</code> is the same as <code>hash_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The object the data will be associated with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The data to store under the key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a memory error allocating the storage. Strong throw guarantee. </td></tr>
    <tr><td class="paramname">???</td><td>If there is an error hashing the key. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29b9c0dd90feffb3569b728f33e01869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b9c0dd90feffb3569b728f33e01869">&#9670;&nbsp;</a></span>cache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::Cache::cache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType &amp;&amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CacheTag &amp;&#160;</td>
          <td class="paramname"><em>tag</em> = <code>CacheTag::Permenant</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores a value under the provided hash value. </p>
<p>This function is a convenience function for cacheing data when the hash of the key is already known (thus allowing you to bypass the cost of hashing again). This overload participates only when <code>key</code> is of type <code>hash_type</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the data being stored. Must be type-erasable via an pluginplayAny.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash the data will be associated with. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The data to store under the key. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tag</td><td>The tag for the key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::bad_alloc</td><td>if there is a memory error allocating the storage. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23113a1e7ce07656e122e3e8c3a20da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23113a1e7ce07656e122e3e8c3a20da6">&#9670;&nbsp;</a></span>count() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::Cache::count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not the cache stores a value associated with the provided hash. </p>
<p>This is a convenience function for looking for a key when we already know the hash of the key (thus allowing you to avoid the cost of hashing). This overload is used when <code>key</code> is of type <code>hash_type</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash associated with the data we are looking for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the cache contains data associated with <code>key</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">None</td><td>No throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac29bb37a478aea8db216499820abd1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac29bb37a478aea8db216499820abd1ab">&#9670;&nbsp;</a></span>count() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyType , typename  = disable_if_hash_t&lt;KeyType&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pluginplay::Cache::count </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether or not the cache stores a value associated with the provided key. </p>
<p>This function can be used to determine if this <a class="el" href="classpluginplay_1_1Cache.html" title="An object for storing data which may be needed after a module has run.">Cache</a> instance is currently storing data associated with a specific key. The key can be any hashable object. This overload is used whenever the type of <code>key</code>, <code>KeyType</code>, is not the same as <code>hash_type</code>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>The type of the object being used as a key. Must be hashable. </td></tr>
    <tr><td class="paramname">&lt;Anonymous&gt;</td><td>Template type parameter used to disable overload when <code>KeyType</code> is the same as <code>hash_type</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>We are looking for data associated with this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the cache contains data associated with <code>key</code> and false otherwise.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">???</td><td>If hashing throws. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7a6ec0338db4feb77f4fe5f2774d032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a6ec0338db4feb77f4fe5f2774d032">&#9670;&nbsp;</a></span>prune_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::Cache::prune_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes temporary values in the cache. </p>
<p>This function deletes the cache values tagged as temporary </p>

</div>
</div>
<a id="a6071ca40eeab03469beb59f828721ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6071ca40eeab03469beb59f828721ddb">&#9670;&nbsp;</a></span>reset_cache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::Cache::reset_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the module cache to an empty map. </p>
<p>This function allows the cache to be emptied of previously stored results </p>

</div>
</div>
<a id="af203dd006b311660a1c6e067f34ff799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af203dd006b311660a1c6e067f34ff799">&#9670;&nbsp;</a></span>set_permanent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::Cache::set_permanent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a given cache key as permanent. </p>
<p>This function sets a given cache key as permanent </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash that the cached data is stored under. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acbe00589b3a6338b98a41ba688f5cfd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe00589b3a6338b98a41ba688f5cfd5">&#9670;&nbsp;</a></span>set_temporary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pluginplay::Cache::set_temporary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a given cache key as temporary. </p>
<p>This function sets a given cache key as temporary </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash that the cached data is stored under. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3408d24a371c85c10c8fd6d3bdfee381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3408d24a371c85c10c8fd6d3bdfee381">&#9670;&nbsp;</a></span>uncache() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType pluginplay::Cache::uncache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing cached data by hash. </p>
<p>This function allows a module to retrieve data that it has previously cached by providing the hash it is cached under. This is a convenience API for when the caller knows the hash already (thereby avoiding the need to hash again).</p>
<dl class="section note"><dt>Note</dt><dd>Whether an object is retrieved by value or reference is determined by the caller, specifically by the caller's choice of <code>ValueType</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the value being retrieved. Must be specified by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash that the cached data is stored under.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached data as an object of type <code>ValueType</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the cache does not contain a value under the provided key. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a1857e470ac0ff0928bced67ca0190e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1857e470ac0ff0928bced67ca0190e">&#9670;&nbsp;</a></span>uncache() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType pluginplay::Cache::uncache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing read-only cached data by hash. </p>
<p>This function allows a module to retrieve data that it has previously cached by providing the hash it is cached under. This is a convenience API for when the caller knows the hash already (thereby avoiding the need to hash again).</p>
<dl class="section note"><dt>Note</dt><dd>Whether an object is retrieved by value or reference is determined by the caller, specifically by the caller's choice of <code>ValueType</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the value being retrieved. Must be specified by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash that the cached data is stored under.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached data as an object of type <code>ValueType</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the cache does not contain a value under the provided key. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fcbffb3faea295043a243e719f26df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fcbffb3faea295043a243e719f26df5">&#9670;&nbsp;</a></span>uncache() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType pluginplay::Cache::uncache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing cached data by hash, return default value if not cached. </p>
<p>This function allows a module to retrieve data that it has previously cached by providing the hash it is cached under. This is a convenience API for when the caller knows the hash already (thereby avoiding the need to hash again). If the key is not present in the cache, the default values provided are returned.</p>
<dl class="section note"><dt>Note</dt><dd>Whether an object is retrieved by value or reference is determined by the caller, specifically by the caller's choice of <code>ValueType</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the value being retrieved. Must be specified by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash that the cached data is stored under.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>The value returned if the key is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached data as an object of type <code>ValueType</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the cache does not contain a value under the provided key. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53493d304fb88eed1041b841b7b3b26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53493d304fb88eed1041b841b7b3b26f">&#9670;&nbsp;</a></span>uncache() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType pluginplay::Cache::uncache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classpluginplay_1_1Cache.html#af69d1d916bd054028a21dd73acdc2cff">hash_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing read-only cached data by hash, return default value if not cached. </p>
<p>This function allows a module to retrieve data that it has previously cached by providing the hash it is cached under. This is a convenience API for when the caller knows the hash already (thereby avoiding the need to hash again). If the key is not present in the cache, the default values provided are returned.</p>
<dl class="section note"><dt>Note</dt><dd>Whether an object is retrieved by value or reference is determined by the caller, specifically by the caller's choice of <code>ValueType</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the value being retrieved. Must be specified by the caller.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The hash that the cached data is stored under.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>The value returned if the key is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached data as an object of type <code>ValueType</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the cache does not contain a value under the provided key. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ee18aa2136878476b64e1a21ef12967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee18aa2136878476b64e1a21ef12967">&#9670;&nbsp;</a></span>uncache() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename KeyType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType pluginplay::Cache::uncache </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing cached data by key. </p>
<p>This function allows a module to retrieve data that it has previously cached by providing the key it is cached under. For API simplicity the key must be a single object; however, the caller can use an <code>std::tuple</code> of objects to satisfy this requirement. This function only participates in overload resolution if the type of <code>key</code>, <code>KeyType</code>, is not <code>hash_type</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Whether an object is retrieved by value or reference is determined by the caller, specifically by the caller's choice of <code>ValueType</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the value being retrieved. Must be specified by the caller. </td></tr>
    <tr><td class="paramname">KeyType</td><td>The type of the object used as a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The value that the cached data is stored under.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached data as an object of type <code>ValueType</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the cache does not contain a value under the provided key. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a306e47d5dd610d21d41e2755f4ecfefd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a306e47d5dd610d21d41e2755f4ecfefd">&#9670;&nbsp;</a></span>uncache() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename KeyType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType pluginplay::Cache::uncache </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing read-only cached data by key. </p>
<p>This function allows a module to retrieve data that it has previously cached by providing the key it is cached under. For API simplicity the key must be a single object; however, the caller can use an <code>std::tuple</code> of objects to satisfy this requirement. This function only participates in overload resolution if the type of <code>key</code>, <code>KeyType</code>, is not <code>hash_type</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Whether an object is retrieved by value or reference is determined by the caller, specifically by the caller's choice of <code>ValueType</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the value being retrieved. Must be specified by the caller. </td></tr>
    <tr><td class="paramname">KeyType</td><td>The type of the object used as a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The value that the cached data is stored under.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached data as an object of type <code>ValueType</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the cache does not contain a value under the provided key. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa19f86c272bb6a237b6472ec571d6063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19f86c272bb6a237b6472ec571d6063">&#9670;&nbsp;</a></span>uncache() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename KeyType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType pluginplay::Cache::uncache </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing cached data by key, return default value if not cached. </p>
<p>This function allows a module to retrieve data that it has previously cached by providing the key it is cached under. For API simplicity the key must be a single object; however, the caller can use an <code>std::tuple</code> of objects to satisfy this requirement. This function only participates in overload resolution if the type of <code>key</code>, <code>KeyType</code>, is not <code>hash_type</code>. If the key is not present in the cache, the default values provided are returned.</p>
<dl class="section note"><dt>Note</dt><dd>Whether an object is retrieved by value or reference is determined by the caller, specifically by the caller's choice of <code>ValueType</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the value being retrieved. Must be specified by the caller. </td></tr>
    <tr><td class="paramname">KeyType</td><td>The type of the object used as a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The value that the cached data is stored under.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>The value returned if the key is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached data of default value as an object of type <code>ValueType</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the cache does not contain a value under the provided key. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52a031d7fa11e4699129b8a50fef412f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a031d7fa11e4699129b8a50fef412f">&#9670;&nbsp;</a></span>uncache() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename KeyType , typename &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType pluginplay::Cache::uncache </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function for accessing read-only cached data by key, return default value if not cached. </p>
<p>This function allows a module to retrieve data that it has previously cached by providing the key it is cached under. For API simplicity the key must be a single object; however, the caller can use an <code>std::tuple</code> of objects to satisfy this requirement. This function only participates in overload resolution if the type of <code>key</code>, <code>KeyType</code>, is not <code>hash_type</code>. If the key is not present in the cache, the default values provided are returned.</p>
<dl class="section note"><dt>Note</dt><dd>Whether an object is retrieved by value or reference is determined by the caller, specifically by the caller's choice of <code>ValueType</code>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ValueType</td><td>The type of the value being retrieved. Must be specified by the caller. </td></tr>
    <tr><td class="paramname">KeyType</td><td>The type of the object used as a key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The value that the cached data is stored under.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">default_value</td><td>The value returned if the key is not found.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cached data as an object of type <code>ValueType</code>.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>if the cache does not contain a value under the provided key. Strong throw guarantee. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/pluginplay/cache/<a class="el" href="cache_8hpp_source.html">cache.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
