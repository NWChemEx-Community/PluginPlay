#pragma once
#include "SDE/ModuleLoader.hpp"
#include <string>

namespace SDE {
namespace detail_ {
/// Forward declaration of PIMPL class
class MMImpl;

} // namespace detail_

class ModuleManager {
public:
    /// The type of the key used to retrieve a module
    using key_type = std::string;

    /// The type of a module loader
    using loader_type = ModuleLoaderBase;

    /// The type of a pointer to a module
    using module_pointer = typename loader_type::module_pointer;

    /**
     * @brief Constructs a new ModuleManager.
     *
     * The resulting ModuleManager has no modules in it.  Modules can be added
     * by using the insert function.
     *
     * @par Complexity:
     * Constant.
     *
     * @par Data Races:
     * None.
     *
     * @throw std::bad_alloc if there is insufficient memory to make a new
     *        instance of the implementation.   Strong throw guarantee.
     */
    ModuleManager();

    /**
     * @brief Takes ownership of another ModuleManager instance.
     * @param rhs The instance to take ownership of.  After this operation
     *        @p rhs is a valid, but otherwise unspecified state.
     * @throw None. No throw guarantee.
     * @par Complexity:
     * Constant.
     */
    ModuleManager(ModuleManager&& rhs) noexcept;

    /**
     * @brief Takes ownership of another ModuleManager instance.
     * @param rhs The instance to take ownership of.  After this operation
     *        @p rhs is a valid, but otherwise unspecified state.
     * @return The current instance containing @p rhs's state.
     * @throw None. No throw guarantee.
     * @par Complexity:
     * Constant.
     */
    ModuleManager& operator=(ModuleManager&& rhs) noexcept;

    /**
     * @brief Frees up all modules managed by this module manager.
     *
     * @throw None. No throw guarantee.
     *
     */
    ~ModuleManager() noexcept;

    /**
     * @brief Adds a module to the current ModuleManager with the associated
     *        key.
     *
     * Each module along with its associated parameters and submodules are
     * stored in the ModuleManager under a unique key.  The current function
     * adds a (presumably) new module to the current instance for management.
     * When requested the module will be generated by calling the `get_module`
     * member function of @p loader.
     *
     * @param key the tag to associate with the module, must be unique and
     *            non-empty.
     * @param loader An instance capable of creating the module.
     * @throws std::range_error if @p key is already registered.  Strong throw
     *         guarantee.
     * @throws std::invalid_argument if @p key is empty.  Strong throw
     *         guarantee.
     * @throws std::bad_alloc if there is insufficient memory to store the
     *         module's data.  Strong throw guarantee.
     *
     * @par Complexity:
     * The actual insertion is logrithmic in the number of modules present.
     *
     */
    void insert(key_type key, const loader_type& loader);

    /**
     * @brief Checks whether or not a module is registered under the provided
     *        key
     *
     * @param key The module key to look for.
     * @return True if @p key is in use and false otherwise
     * @throw None. No throw guarantee.
     *
     * @par Complexity:
     * Logrithmic in the number of modules.
     */
    bool count(const key_type& key) const noexcept;

    /**
     * @brief Can be used to probe if a module has been locked already.
     *
     * Once a user has called ModuleManager::get_module with a particular key
     * that module, and all of its submodules, are locked.  This means that
     * attempting to change the submodules or parameters called by any of those
     * modules will result in an error.  This is to prevent data races which may
     * lead to invalid Cache states.  This function allows a user to inquire
     * into the lock state of a module.
     *
     * @param[in] key The module whose locked-ness is under question.
     * @return True if the module registered under and false otherwise.
     * @throws std::out_of_range if there is no module registered under @p key.
     *         Strong throw guarantee.
     * @par Complexity:
     * Logrithmic in the number of modules.
     */
    bool is_locked(const key_type& key) const;

    /**
     * @brief Copies the parameters and submodules associated with a particular
     *        key to a new key.
     *
     * Once a module is locked there is no way to change its parameters or
     * submodules.  This function will duplicate (deep copy) a module associated
     * with a particular key.  The resulting module will not be locked and thus
     * its parameters and submodules may be changed.
     *
     * @param[in] old_key the key to be duplicated.
     * @param[in] new_key (optional) the key to duplicate @p old_key under.
     *            Must be a valid key, or the null string.  In the event of a
     *            null string, a valid, implementation defined, key will be
     *            generated for you.
     * @return The key under which your new module may be found.
     * @throws std::out_of_range if @p old_key is not an already existing key.
     * @throws std::range_error if @p new_key is already registered and was
     *         specified by the user. Strong throw guarantee.
     * @throws std::bad_alloc if there is insufficient memory to store the
     *         module's data.  Strong throw guarantee.
     * @par Complexity:
     * For all intents and purposes logrithmic in the number of modules;
     * however, this assumes that generation of a valid key is constant.  In the
     * worst case (and unlikely) scenario that this function is limited by
     * generating a unique key, the actual complexity is linear in the number of
     * tries.
     */
    key_type duplicate(const key_type& old_key,
                       const key_type& new_key = key_type{});

    module_pointer get_module(const key_type& key);

    // std::shared_ptr<Parameters> parameters(const key_type& key);

private:
    /// The actual implementation
    std::unique_ptr<detail_::MMImpl> pimpl_;
};

} // namespace SDE
